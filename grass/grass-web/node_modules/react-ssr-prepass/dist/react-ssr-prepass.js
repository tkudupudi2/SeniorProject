"use strict";

var React = require("react");

var React__default = function _interopDefaultLegacy(a) {
  return a && "object" == typeof a && "default" in a ? a : {
    default: a
  };
}(React);

function _extends() {
  return (_extends = Object.assign || function(a) {
    for (var b = 1; b < arguments.length; b++) {
      var d, c = arguments[b];
      for (d in c) {
        Object.prototype.hasOwnProperty.call(c, d) && (a[d] = c[d]);
      }
    }
    return a;
  }).apply(this, arguments);
}

var Element = 60103, Portal = 60106, Fragment = 60107, StrictMode = 60108, Profiler = 60114, ContextProvider = 60109, ContextConsumer = 60110, ConcurrentMode = 60111, ForwardRef = 60112, Suspense = 60113, Memo = 60115, Lazy = 60116;

if ("function" == typeof Symbol && Symbol.for) {
  var symbolFor = Symbol.for;
  Element = symbolFor("react.element");
  Portal = symbolFor("react.portal");
  Fragment = symbolFor("react.fragment");
  StrictMode = symbolFor("react.strict_mode");
  Profiler = symbolFor("react.profiler");
  ContextProvider = symbolFor("react.provider");
  ContextConsumer = symbolFor("react.context");
  ConcurrentMode = Symbol.for("react.concurrent_mode");
  ForwardRef = symbolFor("react.forward_ref");
  Suspense = symbolFor("react.suspense");
  Memo = symbolFor("react.memo");
  Lazy = symbolFor("react.lazy");
}

var REACT_ELEMENT_TYPE = Element, REACT_PORTAL_TYPE = Portal, REACT_FRAGMENT_TYPE = Fragment, REACT_STRICT_MODE_TYPE = StrictMode, REACT_PROFILER_TYPE = Profiler, REACT_PROVIDER_TYPE = ContextProvider, REACT_CONTEXT_TYPE = ContextConsumer, REACT_CONCURRENT_MODE_TYPE = ConcurrentMode, REACT_FORWARD_REF_TYPE = ForwardRef, REACT_SUSPENSE_TYPE = Suspense, REACT_MEMO_TYPE = Memo, REACT_LAZY_TYPE = Lazy, toArray = React.Children.toArray, isAbstractElement = function(a) {
  return null !== a && "object" == typeof a;
}, getChildrenArray = function(a) {
  return toArray(a).filter(isAbstractElement);
}, computeProps = function(a, b) {
  return "object" == typeof b ? _extends({}, b, a) : a;
}, currentContextStore = new Map, currentContextMap = {}, prevContextMap = void 0, prevContextEntry = void 0, getCurrentContextMap = function() {
  return _extends({}, currentContextMap);
}, getCurrentContextStore = function() {
  return new Map(currentContextStore);
}, flushPrevContextMap = function() {
  var a = prevContextMap;
  prevContextMap = void 0;
  return a;
}, flushPrevContextStore = function() {
  var a = prevContextEntry;
  prevContextEntry = void 0;
  return a;
}, restoreContextMap = function(a) {
  void 0 !== a && _extends(currentContextMap, a);
}, restoreContextStore = function(a) {
  void 0 !== a && currentContextStore.set(a[0], a[1]);
}, setCurrentContextMap = function(a) {
  prevContextMap = void 0;
  currentContextMap = a;
}, setCurrentContextStore = function(a) {
  prevContextEntry = void 0;
  currentContextStore = a;
}, readContextValue = function(a) {
  var b = currentContextStore.get(a);
  return void 0 !== b ? b : a._currentValue;
}, emptyContext = {}, maskContext = function(a) {
  var b = a.contextType;
  a = a.contextTypes;
  if (b) {
    return readContextValue(b);
  }
  if (!a) {
    return emptyContext;
  }
  b = {};
  for (var c in a) {
    b[c] = currentContextMap[c];
  }
  return b;
}, currentErrorFrame = null, getCurrentErrorFrame = function() {
  return currentErrorFrame;
}, setCurrentErrorFrame = function(a) {
  currentErrorFrame = a || null;
}, rendererStateRef = {
  current: {
    uniqueID: 0
  }
};

var objectIs = "function" == typeof Object.is ? Object.is : function is(a, b) {
  return a === b && (0 !== a || 1 / a == 1 / b) || a != a && b != b;
}, currentIdentity = null, setCurrentIdentity = function(a) {
  currentIdentity = a;
}, getCurrentIdentity = function() {
  if (null === currentIdentity) {
    throw Error("[react-ssr-prepass] Hooks can only be called inside the body of a function component. (https://fb.me/react-invalid-hook-call)");
  }
  return currentIdentity;
}, firstWorkInProgressHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, renderPhaseUpdates = null, numberOfReRenders = 0, setFirstHook = function(a) {
  firstWorkInProgressHook = a;
};

function createWorkInProgressHook() {
  return null === workInProgressHook ? null === firstWorkInProgressHook ? firstWorkInProgressHook = workInProgressHook = {
    memoizedState: null,
    queue: null,
    next: null
  } : workInProgressHook = firstWorkInProgressHook : null === workInProgressHook.next ? workInProgressHook = workInProgressHook.next = {
    memoizedState: null,
    queue: null,
    next: null
  } : workInProgressHook = workInProgressHook.next;
}

function basicStateReducer(a, b) {
  return "function" == typeof b ? b(a) : b;
}

function useReducer(a, b, c) {
  var d = getCurrentIdentity();
  null === (workInProgressHook = createWorkInProgressHook()).queue && (b = a === basicStateReducer ? "function" == typeof b ? b() : b : void 0 !== c ? c(b) : b, 
  workInProgressHook.memoizedState = b);
  d = (b = workInProgressHook.queue || (workInProgressHook.queue = {
    last: null,
    dispatch: null
  })).dispatch || (b.dispatch = dispatchAction.bind(null, d, b));
  if (null !== renderPhaseUpdates && void 0 !== (c = renderPhaseUpdates.get(b))) {
    renderPhaseUpdates.delete(b);
    b = workInProgressHook.memoizedState;
    do {
      b = a(b, c.action), c = c.next;
    } while (null !== c);
    workInProgressHook.memoizedState = b;
  }
  return [ workInProgressHook.memoizedState, d ];
}

function useMemo(a, b) {
  getCurrentIdentity();
  b = void 0 === b ? null : b;
  var c = (workInProgressHook = createWorkInProgressHook()).memoizedState;
  if (null !== c && null !== b && function areHookInputsEqual(a, b) {
    if (null === b) {
      return !1;
    }
    for (var c = 0; c < b.length && c < a.length; c++) {
      if (!objectIs(a[c], b[c])) {
        return !1;
      }
    }
    return !0;
  }(b, c[1])) {
    return c[0];
  }
  a = a();
  workInProgressHook.memoizedState = [ a, b ];
  return a;
}

function dispatchAction(a, b, c) {
  if (a === currentIdentity) {
    if (didScheduleRenderPhaseUpdate = !0, a = {
      action: c,
      next: null
    }, null === renderPhaseUpdates && (renderPhaseUpdates = new Map), void 0 === (c = renderPhaseUpdates.get(b))) {
      renderPhaseUpdates.set(b, a);
    } else {
      for (b = c; null !== b.next; ) {
        b = b.next;
      }
      b.next = a;
    }
  }
}

function noop() {}

function _ref$2(a) {
  a();
}

var Dispatcher = {
  readContext: function readContext(a, b) {
    return readContextValue(a);
  },
  useContext: function useContext(a, b) {
    getCurrentIdentity();
    return readContextValue(a);
  },
  useMemo: useMemo,
  useReducer: useReducer,
  useRef: function useRef(a) {
    getCurrentIdentity();
    var b = (workInProgressHook = createWorkInProgressHook()).memoizedState;
    return null === b ? workInProgressHook.memoizedState = a = {
      current: a
    } : b;
  },
  useState: function useState(a) {
    return useReducer(basicStateReducer, a);
  },
  useCallback: function useCallback(a, b) {
    return useMemo((function() {
      return a;
    }), b);
  },
  useMutableSource: function useMutableSource(a, b, c) {
    getCurrentIdentity();
    return b(a._source);
  },
  useTransition: function useTransition() {
    return [ _ref$2, !1 ];
  },
  useDeferredValue: function useDeferredValue(a) {
    return a;
  },
  useOpaqueIdentifier: function useOpaqueIdentifier() {
    getCurrentIdentity();
    (workInProgressHook = createWorkInProgressHook()).memoizedState || (workInProgressHook.memoizedState = "R:" + (rendererStateRef.current.uniqueID++).toString(36));
    return workInProgressHook.memoizedState;
  },
  useLayoutEffect: noop,
  useImperativeHandle: noop,
  useEffect: noop,
  useDebugValue: noop
}, resolve = function(a) {
  var b = a._payload || a;
  if (0 === b._status) {
    return b._result;
  }
  if (1 === b._status) {
    return Promise.resolve(b._result);
  }
  if (2 === b._status) {
    return Promise.reject(b._result);
  }
  b._status = 0;
  return b._result = (b._ctor || b._result)().then((function(a) {
    b._result = a;
    "function" == typeof a ? b._status = 1 : null !== a && "object" == typeof a && "function" == typeof a.default ? (b._result = a.default, 
    b._status = 1) : b._status = 2;
  })).catch((function(a) {
    b._status = 2;
    b._result = a;
    return Promise.reject(a);
  }));
}, render$3 = function(a, b, c) {
  return 1 === (a = a._payload || a)._status ? React.createElement(a._result, b) : null;
}, makeFrame$1 = function(a, b, c) {
  return {
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    id: getCurrentIdentity(),
    hook: firstWorkInProgressHook,
    kind: "frame.hooks",
    errorFrame: getCurrentErrorFrame(),
    thenable: c,
    props: b,
    type: a
  };
}, render$2 = function(a, b, c) {
  try {
    return function renderWithHooks(a, b, c) {
      workInProgressHook = null;
      for (var d = a(b, c); numberOfReRenders < 25 && didScheduleRenderPhaseUpdate; ) {
        didScheduleRenderPhaseUpdate = !1, numberOfReRenders += 1, workInProgressHook = null, 
        d = a(b, c);
      }
      numberOfReRenders = 0;
      workInProgressHook = renderPhaseUpdates = null;
      return d;
    }(a, computeProps(b, a.defaultProps), maskContext(a));
  } catch (d) {
    if ("function" != typeof d.then) {
      throw d;
    }
    c.push(makeFrame$1(a, b, d));
    return null;
  }
};

function _ref$1() {
  return !1;
}

function _ref2() {
  return null;
}

var createInstance = function(a, b) {
  var c = function() {
    var a = [];
    return {
      _thrown: 0,
      queue: a,
      isMounted: _ref$1,
      enqueueForceUpdate: _ref2,
      enqueueReplaceState: function(b, c) {
        b._isMounted && (a.length = 0, a.push(c));
      },
      enqueueSetState: function(b, c) {
        b._isMounted && a.push(c);
      }
    };
  }(), d = computeProps(b, a.defaultProps), e = maskContext(a);
  (b = new a(d, e, c)).props = d;
  b.context = e;
  b.updater = c;
  b._isMounted = !0;
  void 0 === b.state && (b.state = null);
  if ("function" == typeof b.componentDidCatch || "function" == typeof a.getDerivedStateFromError) {
    (c = makeFrame(a, b, null)).errorFrame = c, setCurrentErrorFrame(c);
  }
  "function" == typeof a.getDerivedStateFromProps ? null != (a = (a = a.getDerivedStateFromProps)(b.props, b.state)) && (b.state = _extends({}, b.state, a)) : "function" == typeof b.componentWillMount ? b.componentWillMount() : "function" == typeof b.UNSAFE_componentWillMount && b.UNSAFE_componentWillMount();
  return b;
}, makeFrame = function(a, b, c) {
  return {
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    errorFrame: getCurrentErrorFrame(),
    thenable: c,
    kind: "frame.class",
    error: null,
    instance: b,
    type: a
  };
}, render$1 = function(a, b, c) {
  !function(a) {
    var b = a.updater.queue;
    if (0 < b.length) {
      for (var c = _extends({}, a.state), d = 0, e = b.length; d < e; d++) {
        var f = b[d];
        null !== (f = "function" == typeof f ? f.call(a, c, a.props, a.context) : f) && _extends(c, f);
      }
      a.state = c;
      b.length = 0;
    }
  }(b);
  var d = null;
  try {
    d = b.render();
  } catch (e) {
    if ("function" != typeof e.then) {
      throw e;
    }
    c.push(makeFrame(a, b, e));
    return null;
  }
  void 0 !== a.childContextTypes && "function" == typeof b.getChildContext && (null !== (a = b.getChildContext()) && "object" == typeof a && function(a) {
    prevContextMap = {};
    for (var b in a) {
      prevContextMap[b] = currentContextMap[b], currentContextMap[b] = a[b];
    }
  }(a));
  if ("function" != typeof b.getDerivedStateFromProps && ("function" == typeof b.componentWillMount || "function" == typeof b.UNSAFE_componentWillMount) && "function" == typeof b.componentWillUnmount) {
    try {
      b.componentWillUnmount();
    } catch (e) {}
  }
  b._isMounted = !1;
  return d;
}, ReactCurrentDispatcher = React__default.default.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher, SHOULD_YIELD = "function" == typeof setImmediate, render = function(a, b, c, d, e) {
  return function(a) {
    return a.prototype && a.prototype.isReactComponent;
  }(a) ? function(a, b, c, d, e) {
    setCurrentIdentity(null);
    return (d = d(e, b = createInstance(a, b))) ? (c.push(makeFrame(a, b, d)), null) : render$1(a, b, c);
  }(a, b, c, d, e) : function(a, b, c, d, e) {
    setFirstHook(null);
    setCurrentIdentity({});
    return (d = d(e)) ? (c.push(makeFrame$1(a, b, d)), null) : render$2(a, b, c);
  }(a, b, c, d, e);
}, visitElement = function(a, b, c) {
  switch (function(a) {
    switch (a.$$typeof) {
     case REACT_PORTAL_TYPE:
      return REACT_PORTAL_TYPE;

     case REACT_ELEMENT_TYPE:
      switch (a.type) {
       case REACT_CONCURRENT_MODE_TYPE:
        return REACT_CONCURRENT_MODE_TYPE;

       case REACT_FRAGMENT_TYPE:
        return REACT_FRAGMENT_TYPE;

       case REACT_PROFILER_TYPE:
        return REACT_PROFILER_TYPE;

       case REACT_STRICT_MODE_TYPE:
        return REACT_STRICT_MODE_TYPE;

       case REACT_SUSPENSE_TYPE:
        return REACT_SUSPENSE_TYPE;

       default:
        switch (a.type && a.type.$$typeof) {
         case REACT_LAZY_TYPE:
          return REACT_LAZY_TYPE;

         case REACT_MEMO_TYPE:
          return REACT_MEMO_TYPE;

         case REACT_CONTEXT_TYPE:
          return REACT_CONTEXT_TYPE;

         case REACT_PROVIDER_TYPE:
          return REACT_PROVIDER_TYPE;

         case REACT_FORWARD_REF_TYPE:
          return REACT_FORWARD_REF_TYPE;

         default:
          return REACT_ELEMENT_TYPE;
        }
      }
    }
  }(a)) {
   case REACT_SUSPENSE_TYPE:
   case REACT_STRICT_MODE_TYPE:
   case REACT_CONCURRENT_MODE_TYPE:
   case REACT_PROFILER_TYPE:
   case REACT_FRAGMENT_TYPE:
    return getChildrenArray(a.props.children);

   case REACT_PROVIDER_TYPE:
    return c = (b = a.props).children, function(a, b) {
      prevContextEntry = [ a, currentContextStore.get(a) ];
      currentContextStore.set(a, b);
    }(a.type._context, b.value), getChildrenArray(c);

   case REACT_CONTEXT_TYPE:
    return "function" == typeof (b = a.props.children) ? (a = readContextValue("object" == typeof (a = a.type)._context ? a._context : a), 
    getChildrenArray(b(a))) : [];

   case REACT_LAZY_TYPE:
    return a = function(a, b, c) {
      return 0 >= (a._payload || a)._status ? (c.push({
        kind: "frame.lazy",
        contextMap: getCurrentContextMap(),
        contextStore: getCurrentContextStore(),
        errorFrame: getCurrentErrorFrame(),
        thenable: resolve(a),
        props: b,
        type: a
      }), null) : render$3(a, b);
    }(a.type, a.props, b), getChildrenArray(a);

   case REACT_MEMO_TYPE:
    return a = React.createElement(a.type.type, a.props), getChildrenArray(a);

   case REACT_FORWARD_REF_TYPE:
    return b = (c = a.type).render, a = computeProps(a.props, c.defaultProps), a = React.createElement(b, a), 
    getChildrenArray(a);

   case REACT_ELEMENT_TYPE:
    if ("string" == typeof a.type) {
      return getChildrenArray(a.props.children);
    }
    a = render(a.type, a.props, b, c, a);
    return getChildrenArray(a);

   default:
    return [];
  }
}, visitLoop = function(a, b, c, d, e, f) {
  var g = ReactCurrentDispatcher.current, m = Date.now();
  try {
    for (ReactCurrentDispatcher.current = Dispatcher; 0 < a.length; ) {
      var k = a[a.length - 1].shift();
      if (void 0 !== k) {
        var n = visitElement(k, e, f);
        a.push(n);
        b.push(flushPrevContextMap());
        c.push(flushPrevContextStore());
        d.push(getCurrentErrorFrame());
      } else {
        a.pop(), restoreContextMap(b.pop()), restoreContextStore(c.pop()), setCurrentErrorFrame(d.pop());
      }
      if (SHOULD_YIELD && Date.now() - m > 5) {
        return !0;
      }
    }
    return !1;
  } catch (l) {
    var h = getCurrentErrorFrame();
    if (!h) {
      throw l;
    }
    h.error = l;
    e.unshift(h);
    return !1;
  } finally {
    ReactCurrentDispatcher.current = g;
  }
}, makeYieldFrame = function(a, b, c, d) {
  return {
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    errorFrame: getCurrentErrorFrame(),
    thenable: null,
    kind: "frame.yield",
    traversalChildren: a,
    traversalMap: b,
    traversalStore: c,
    traversalErrorFrame: d
  };
}, visit = function(a, b, c) {
  a = [ a ];
  var d = [ flushPrevContextMap() ], e = [ flushPrevContextStore() ], f = [ getCurrentErrorFrame() ];
  visitLoop(a, d, e, f, b, c) && b.unshift(makeYieldFrame(a, d, e, f));
}, update = function(a, b, c) {
  if ("frame.yield" === a.kind) {
    setCurrentIdentity(null), setCurrentContextMap(a.contextMap), setCurrentContextStore(a.contextStore), 
    setCurrentErrorFrame(a.errorFrame), visitLoop(a.traversalChildren, a.traversalMap, a.traversalStore, a.traversalErrorFrame, b, c) && b.unshift(makeYieldFrame(a.traversalChildren, a.traversalMap, a.traversalStore, a.traversalErrorFrame));
  } else {
    var d = ReactCurrentDispatcher.current, e = null;
    ReactCurrentDispatcher.current = Dispatcher;
    try {
      "frame.class" === a.kind ? e = function(a, b) {
        setCurrentIdentity(null);
        setCurrentContextMap(b.contextMap);
        setCurrentContextStore(b.contextStore);
        setCurrentErrorFrame(b.errorFrame);
        if (b.error) {
          if (++b.instance.updater._thrown >= 25) {
            return null;
          }
          b.instance._isMounted = !0;
          "function" == typeof b.instance.componentDidCatch && b.instance.componentDidCatch(b.error);
          "function" == typeof b.type.getDerivedStateFromError && b.instance.updater.enqueueSetState(b.instance, b.type.getDerivedStateFromError(b.error));
        }
        return render$1(b.type, b.instance, a);
      }(b, a) : "frame.hooks" === a.kind ? e = function(a, b) {
        setFirstHook(b.hook);
        setCurrentIdentity(b.id);
        setCurrentContextMap(b.contextMap);
        setCurrentContextStore(b.contextStore);
        setCurrentErrorFrame(b.errorFrame);
        return render$2(b.type, b.props, a);
      }(b, a) : "frame.lazy" === a.kind && (e = function(a, b) {
        setCurrentIdentity(null);
        setCurrentContextMap(b.contextMap);
        setCurrentContextStore(b.contextStore);
        setCurrentErrorFrame(b.errorFrame);
        return render$3(b.type, b.props);
      }(0, a));
    } catch (g) {
      var f = getCurrentErrorFrame();
      if (!f) {
        throw g;
      }
      f.error = g;
      b.unshift(f);
      e = null;
    } finally {
      ReactCurrentDispatcher.current = d;
    }
    visit(getChildrenArray(e), b, c);
  }
};

function _ref(a, b) {
  setImmediate(a);
}

var flushFrames = function(a, b, c) {
  var d = a.shift();
  if (!d) {
    return Promise.resolve();
  }
  SHOULD_YIELD && "frame.yield" === d.kind && (d.thenable = new Promise(_ref));
  return Promise.resolve(d.thenable).then((function() {
    !function(a) {
      rendererStateRef.current = a;
    }(c);
    update(d, a, b);
    return flushFrames(a, b, c);
  }), (function(c) {
    if (!d.errorFrame) {
      throw c;
    }
    d.errorFrame.error = c;
    update(d.errorFrame, a, b);
  }));
}, defaultVisitor = function() {};

module.exports = function(a, b) {
  b || (b = defaultVisitor);
  var c = [], d = rendererStateRef.current = {
    uniqueID: 0
  };
  setCurrentContextMap({});
  setCurrentContextStore(new Map);
  setCurrentErrorFrame(null);
  try {
    visit(getChildrenArray(a), c, b);
  } catch (e) {
    return Promise.reject(e);
  }
  return flushFrames(c, b, d);
};
//# sourceMappingURL=react-ssr-prepass.js.map
