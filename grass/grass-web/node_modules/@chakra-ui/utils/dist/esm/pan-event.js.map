{"version":3,"sources":["../../src/pan-event.ts"],"names":["sync","cancelSync","isMouseEvent","extractEventInfo","addPointerEvent","isMultiTouchEvent","pipe","distance","noop","PanSession","constructor","event","handlers","threshold","lastEvent","lastEventInfo","info","getPanInfo","history","isPanStarted","startEvent","isDistancePastThreshold","offset","x","y","push","point","onStart","onMove","buttons","onPointerUp","update","updatePoint","end","onEnd","panInfo","stopPropagation","preventDefault","onSessionStart","removeListeners","window","onPointerMove","updateHandlers","subtractPoint","a","b","startPanPoint","lastPanPoint","length","delta"],"mappings":"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","sourcesContent":["/**\n * This is a modified version of `PanSession` from `framer-motion`.\n *\n * Credit goes to `framer-motion` of this useful utilities.\n * License can be found here: https://github.com/framer/motion\n */\n\nimport sync, { cancelSync } from \"framesync\"\nimport {\n  isMouseEvent,\n  extractEventInfo,\n  addPointerEvent,\n  AnyPointerEvent,\n  Point,\n  PointerEventInfo,\n  isMultiTouchEvent,\n} from \"./pointer-event\"\nimport { pipe, distance, noop } from \"./function\"\n\n/**\n * The event information passed to pan event handlers like `onPan`, `onPanStart`.\n *\n * It contains information about the current state of the tap gesture such as its\n * `point`, `delta`, and `offset`\n */\nexport interface PanEventInfo {\n  /**\n   * Contains `x` and `y` values for the current pan position relative\n   * to the device or page.\n   */\n  point: Point\n  /**\n   * Contains `x` and `y` values for the distance moved since\n   * the last pan event.\n   */\n  delta: Point\n  /**\n   * Contains `x` and `y` values for the distance moved from\n   * the first pan event.\n   */\n  offset: Point\n}\n\nexport type PanHandler = (event: AnyPointerEvent, info: PanEventInfo) => void\n\nexport interface PanSessionHandlers {\n  /**\n   * Callback fired when the pan session is created.\n   * This is typically called once `pointerdown` event is fired.\n   */\n  onSessionStart: PanHandler\n  /**\n   * Callback fired when the pan session has started.\n   * The pan session when the pan offset is greater than\n   * the threshold (allowable move distance to detect pan)\n   */\n  onStart: PanHandler\n  /**\n   * Callback fired while panning\n   */\n  onMove: PanHandler\n  /**\n   * Callback fired when the current pan session has end.\n   * This is typically called once `pointerup` event is fired.\n   */\n  onEnd: PanHandler\n}\n\n/**\n * @internal\n *\n * A Pan Session is recognized when the pointer is down\n * and moved in the allowed direction.\n */\nexport class PanSession {\n  /**\n   * We use this to keep track of the `x` and `y` pan session history\n   * as the pan event happens. It helps to calculate the `offset` and `delta`\n   */\n  private history: Point[] = []\n\n  // The pointer event that started the pan session\n  private startEvent: AnyPointerEvent | null = null\n\n  // The current pointer event for the pan session\n  private lastEvent: AnyPointerEvent | null = null\n\n  // The current pointer event info for the pan session\n  private lastEventInfo: PointerEventInfo | null = null\n\n  private handlers: Partial<PanSessionHandlers> = {}\n\n  private removeListeners: Function = noop\n\n  /**\n   * Minimal pan distance required before recognizing the pan.\n   * @default \"3px\"\n   */\n  private threshold = 3\n\n  constructor(\n    event: AnyPointerEvent,\n    handlers: Partial<PanSessionHandlers>,\n    threshold?: number,\n  ) {\n    // If we have more than one touch, don't start detecting this gesture\n    if (isMultiTouchEvent(event)) return\n\n    this.handlers = handlers\n\n    if (threshold) {\n      this.threshold = threshold\n    }\n\n    // stop default browser behavior\n    event.stopPropagation()\n    event.preventDefault()\n\n    // get and save the `pointerdown` event info in history\n    // we'll use it to compute the `offset`\n    const info = extractEventInfo(event)\n    this.history = [info.point]\n\n    // notify pan session start\n    const { onSessionStart } = handlers\n    onSessionStart?.(event, getPanInfo(info, this.history))\n\n    // attach event listeners and return a single function to remove them all\n    this.removeListeners = pipe(\n      addPointerEvent(window, \"pointermove\", this.onPointerMove),\n      addPointerEvent(window, \"pointerup\", this.onPointerUp),\n      addPointerEvent(window, \"pointercancel\", this.onPointerUp),\n    )\n  }\n\n  private updatePoint = () => {\n    if (!(this.lastEvent && this.lastEventInfo)) return\n\n    const info = getPanInfo(this.lastEventInfo, this.history)\n\n    const isPanStarted = this.startEvent !== null\n\n    const isDistancePastThreshold =\n      distance(info.offset, { x: 0, y: 0 }) >= this.threshold\n\n    if (!isPanStarted && !isDistancePastThreshold) return\n\n    this.history.push(info.point)\n\n    const { onStart, onMove } = this.handlers\n\n    if (!isPanStarted) {\n      onStart?.(this.lastEvent, info)\n      this.startEvent = this.lastEvent\n    }\n\n    onMove?.(this.lastEvent, info)\n  }\n\n  private onPointerMove = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    this.lastEvent = event\n    this.lastEventInfo = info\n\n    // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n    if (isMouseEvent(event) && event.buttons === 0) {\n      this.onPointerUp(event, info)\n      return\n    }\n\n    // Throttle mouse move event to once per frame\n    sync.update(this.updatePoint, true)\n  }\n\n  private onPointerUp = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    this.end()\n\n    const { onEnd } = this.handlers\n    if (!onEnd || !this.startEvent) return\n\n    const panInfo = getPanInfo(info, this.history)\n    onEnd?.(event, panInfo)\n  }\n\n  updateHandlers(handlers: Partial<PanSessionHandlers>) {\n    this.handlers = handlers\n  }\n\n  end() {\n    this.removeListeners?.()\n    cancelSync.update(this.updatePoint)\n  }\n}\n\nfunction subtractPoint(a: Point, b: Point) {\n  return { x: a.x - b.x, y: a.y - b.y }\n}\n\nfunction startPanPoint(history: Point[]) {\n  return history[0]\n}\n\nfunction lastPanPoint(history: Point[]) {\n  return history[history.length - 1]\n}\n\nfunction getPanInfo(info: PointerEventInfo, history: Point[]) {\n  return {\n    point: info.point,\n    delta: subtractPoint(info.point, lastPanPoint(history)),\n    offset: subtractPoint(info.point, startPanPoint(history)),\n  }\n}\n"],"file":"pan-event.js"}