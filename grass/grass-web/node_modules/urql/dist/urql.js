function _extends() {
  return (_extends = Object.assign || function(target) {
    var i, source, key;
    for (i = 1; i < arguments.length; i++) {
      source = arguments[i];
      for (key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }).apply(this, arguments);
}

function useMutation(query) {
  function _ref(result) {
    if (isMounted.current) {
      setState({
        fetching: !1,
        stale: !!result.stale,
        data: result.data,
        error: result.error,
        extensions: result.extensions,
        operation: result.operation
      });
    }
    return result;
  }
  function _ref2() {
    isMounted.current = !1;
  }
  var isMounted = react.useRef(!0), client = useClient(), ref = react.useState(initialState), state = ref[0], setState = ref[1], executeMutation = react.useCallback((function(variables, context) {
    setState(_extends({}, initialState, {
      fetching: !0
    }));
    return wonka.toPromise(client.executeMutation(core.createRequest(query, variables), context || {})).then(_ref);
  }), [ client, query, setState ]);
  react.useEffect((function() {
    return _ref2;
  }), []);
  return [ state, executeMutation ];
}

function useRequest(query, variables) {
  var prev = react.useRef(void 0);
  return react.useMemo((function() {
    var request = core.createRequest(query, variables);
    if (void 0 !== prev.current && prev.current.key === request.key) {
      return prev.current;
    } else {
      prev.current = request;
      return request;
    }
  }), [ query, variables ]);
}

function useQuery(args) {
  function _ref(result) {
    cache.set(request.key, result);
  }
  var client = useClient(), cache = getCacheForClient(client), suspense = isSuspense(client, args.context), request = useRequest(args.query, args.variables), source = react.useMemo((function() {
    if (args.pause) {
      return null;
    }
    var source = client.executeQuery(request, _extends({}, {
      requestPolicy: args.requestPolicy
    }, args.context));
    return suspense ? wonka.onPush(_ref)(source) : source;
  }), [ client, request, suspense, args.pause, args.requestPolicy, args.context ]), getSnapshot = react.useCallback((function(source, suspense) {
    var result, resolve, subscription, promise;
    if (!source) {
      return {
        fetching: !1
      };
    }
    if (!(result = cache.get(request.key))) {
      subscription = wonka.subscribe((function _ref2(_result) {
        result = _result;
        if (resolve) {
          resolve(result);
        }
      }))(wonka.takeWhile((function _ref3() {
        return suspense && !resolve || !result;
      }))(source));
      if (null == result && suspense) {
        promise = new Promise((function _ref4(_resolve) {
          resolve = _resolve;
        }));
        cache.set(request.key, promise);
        throw promise;
      } else {
        subscription.unsubscribe();
      }
    } else if (suspense && null != result && "then" in result) {
      throw result;
    }
    return result || {
      fetching: !0
    };
  }), [ request ]), deps = [ client, request, args.requestPolicy, args.context, args.pause ], ref = react.useState((function() {
    currentInit = !0;
    try {
      return [ source, computeNextState(initialState, getSnapshot(source, suspense)), deps ];
    } finally {
      currentInit = !1;
    }
  })), state = ref[0], setState = ref[1], currentResult = state[1];
  if (source !== state[0] && hasDepsChanged(state[2], deps)) {
    setState([ source, currentResult = computeNextState(state[1], getSnapshot(source, suspense)), deps ]);
  }
  react.useEffect((function() {
    var subscription, source = state[0], request = state[2][1], hasResult = !1, updateResult = function(result) {
      hasResult = !0;
      if (!currentInit) {
        setState((function _ref5(state) {
          var nextResult = computeNextState(state[1], result);
          return state[1] !== nextResult ? [ state[0], nextResult, state[2] ] : state;
        }));
      }
    };
    if (source) {
      subscription = wonka.subscribe(updateResult)(wonka.onEnd((function _ref6() {
        updateResult({
          fetching: !1
        });
      }))(source));
      if (!hasResult) {
        updateResult({
          fetching: !0
        });
      }
      return function _ref7() {
        cache.dispose(request.key);
        subscription.unsubscribe();
      };
    } else {
      updateResult({
        fetching: !1
      });
    }
  }), [ cache, state[0], state[2][1] ]);
  return [ currentResult, react.useCallback((function(opts) {
    var context = _extends({}, {
      requestPolicy: args.requestPolicy
    }, args.context, opts), source = client.executeQuery(request, context);
    setState((function(state) {
      var snapshot = "network-only" !== context.requestPolicy ? getSnapshot(source, !1) : {
        fetching: !0
      }, nextResult = computeNextState(state[1], snapshot);
      return state[1] !== nextResult ? [ source, nextResult, state[2] ] : state;
    }));
  }), [ client, request, getSnapshot, args.requestPolicy, args.context ]) ];
}

function useSubscription(args, handler) {
  function _ref(result) {
    setState((function(state) {
      var nextResult = computeNextState(state[1], result);
      if (state[1] === nextResult) {
        return state;
      }
      if (handlerRef.current && state[1].data !== nextResult.data) {
        nextResult.data = handlerRef.current(state[1].data, nextResult.data);
      }
      return [ state[0], nextResult, state[2] ];
    }));
  }
  var source, deps, ref, state, setState, currentResult, client = useClient(), request = useRequest(args.query, args.variables), handlerRef = react.useRef(handler);
  handlerRef.current = handler;
  source = react.useMemo((function() {
    return !args.pause ? client.executeSubscription(request, args.context) : null;
  }), [ client, request, args.pause, args.context ]);
  deps = [ client, request, args.context, args.pause ];
  ref = react.useState((function() {
    return [ source, _extends({}, initialState, {
      fetching: !!source
    }), deps ];
  }));
  setState = ref[1];
  currentResult = (state = ref[0])[1];
  if (source !== state[0] && hasDepsChanged(state[2], deps)) {
    setState([ source, currentResult = computeNextState(state[1], {
      fetching: !!source
    }), deps ]);
  }
  react.useEffect((function() {
    var updateResult = _ref;
    if (state[0]) {
      return wonka.subscribe(updateResult)(wonka.onEnd((function _ref2() {
        updateResult({
          fetching: !1
        });
      }))(state[0])).unsubscribe;
    } else {
      updateResult({
        fetching: !1
      });
    }
  }), [ state[0] ]);
  return [ currentResult, react.useCallback((function(opts) {
    var source = client.executeSubscription(request, _extends({}, args.context, opts));
    setState((function(state) {
      return [ source, state[1], state[2] ];
    }));
  }), [ client, args.context, request ]) ];
}

var hasWarnedAboutDefault, useClient, initialState, isShallowDifferent, computeNextState, hasDepsChanged, getCacheForClient, isSuspense, currentInit, core = require("@urql/core"), react = require("react"), wonka = require("wonka"), defaultClient = core.createClient({
  url: "/graphql"
}), Context = react.createContext(defaultClient), Provider = Context.Provider, Consumer = Context.Consumer;

Context.displayName = "UrqlContext";

hasWarnedAboutDefault = !1;

useClient = function() {
  var client = react.useContext(Context);
  if ("production" !== process.env.NODE_ENV && client === defaultClient && !hasWarnedAboutDefault) {
    hasWarnedAboutDefault = !0;
    console.warn("Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\nIf that's not what you want, please create a client and add a Provider.");
  }
  return client;
};

initialState = {
  fetching: !1,
  stale: !1,
  error: void 0,
  data: void 0,
  extensions: void 0,
  operation: void 0
};

isShallowDifferent = function(a, b) {
  var x, x$1;
  if ("object" != typeof a || "object" != typeof b) {
    return a !== b;
  }
  for (x in a) {
    if (!(x in b)) {
      return !0;
    }
  }
  for (x$1 in b) {
    if (a[x$1] !== b[x$1]) {
      return !0;
    }
  }
  return !1;
};

computeNextState = function(prevState, result) {
  var newState = _extends({}, prevState, result, {
    fetching: !!result.fetching,
    stale: !!result.stale
  });
  return isShallowDifferent(prevState, newState) ? newState : prevState;
};

hasDepsChanged = function(a, b) {
  for (var i = 0, l = b.length; i < l; i++) {
    if (a[i] !== b[i]) {
      return !0;
    }
  }
  return !1;
};

getCacheForClient = function(client) {
  var reclaim, map;
  if (!client._react) {
    reclaim = new Set;
    map = new Map;
    if (client.operations$) {
      wonka.subscribe((function _ref(operation) {
        if ("teardown" === operation.kind && reclaim.has(operation.key)) {
          reclaim.delete(operation.key);
          map.delete(operation.key);
        }
      }))(client.operations$);
    }
    client._react = {
      get: function _get(key) {
        return map.get(key);
      },
      set: function _set(key, value) {
        reclaim.delete(key);
        map.set(key, value);
      },
      dispose: function _dispose(key) {
        reclaim.add(key);
      }
    };
  }
  return client._react;
};

isSuspense = function(client, context) {
  return client.suspense && (!context || !1 !== context.suspense);
};

currentInit = !1;

Object.keys(core).forEach((function(k) {
  if ("default" !== k) {
    exports[k] = core[k];
  }
}));

exports.Consumer = Consumer;

exports.Context = Context;

exports.Mutation = function Mutation(props) {
  var mutation = useMutation(props.query);
  return props.children(_extends({}, mutation[0], {
    executeMutation: mutation[1]
  }));
};

exports.Provider = Provider;

exports.Query = function Query(props) {
  var query = useQuery(props);
  return props.children(_extends({}, query[0], {
    executeQuery: query[1]
  }));
};

exports.Subscription = function Subscription(props) {
  var subscription = useSubscription(props, props.handler);
  return props.children(_extends({}, subscription[0], {
    executeSubscription: subscription[1]
  }));
};

exports.useClient = useClient;

exports.useMutation = useMutation;

exports.useQuery = useQuery;

exports.useSubscription = useSubscription;
//# sourceMappingURL=urql.js.map
