function _extends() {
  return (_extends = Object.assign || function(target) {
    var i, source, key;
    for (i = 1; i < arguments.length; i++) {
      source = arguments[i];
      for (key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }).apply(this, arguments);
}

function resetClient() {
  urqlClient = null;
}

function _ref() {
  return null;
}

function initUrqlClient(clientOptions, canEnableSuspense) {
  var isServer = "undefined" == typeof window;
  if (isServer || !urqlClient) {
    (urqlClient = createClient(_extends({}, clientOptions, {
      suspense: canEnableSuspense && (isServer || clientOptions.suspense)
    }))).toJSON = _ref;
  }
  return urqlClient;
}

function _ref$1() {}

function withUrqlClient(getClientConfig, options) {
  if (!options) {
    options = {};
  }
  return function(AppOrPage) {
    var shouldEnableSuspense = Boolean((AppOrPage.getInitialProps || options.ssr) && !options.neverSuspend), WithUrql = function(ref) {
      var pageProps = ref.pageProps, urqlClient = ref.urqlClient, urqlState = ref.urqlState, rest$1 = function objectWithoutProperties(obj, exclude) {
        var k, target = {};
        for (k in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, k) && -1 === exclude.indexOf(k)) {
            target[k] = obj[k];
          }
        }
        return target;
      }(ref, [ "pageProps", "urqlClient", "urqlState" ]), rest = rest$1, forceUpdate = useState(0), urqlServerState = pageProps && pageProps.urqlState || urqlState, client = React.useMemo((function() {
        if (urqlClient) {
          return urqlClient;
        }
        if (!ssr || "undefined" == typeof window) {
          ssr = ssrExchange({
            initialState: urqlServerState,
            isClient: !0
          });
        }
        var clientConfig = getClientConfig(ssr);
        if (!clientConfig.exchanges) {
          clientConfig.exchanges = [ dedupExchange, cacheExchange, ssr, fetchExchange ];
        }
        return initUrqlClient(clientConfig, shouldEnableSuspense);
      }), [ urqlClient, urqlServerState, forceUpdate[0] ]), resetUrqlClient = function() {
        resetClient();
        ssr = ssrExchange({
          initialState: void 0
        });
        forceUpdate[1](forceUpdate[0] + 1);
      };
      return createElement(Provider, {
        value: client
      }, createElement(AppOrPage, _extends({}, rest, {
        pageProps: pageProps,
        urqlClient: client,
        resetUrqlClient: resetUrqlClient
      })));
    }, displayName = AppOrPage.displayName || AppOrPage.name || "Component";
    WithUrql.displayName = "withUrqlClient(" + displayName + ")";
    if (AppOrPage.getInitialProps || options.ssr) {
      WithUrql.getInitialProps = function _ref4(appOrPageCtx) {
        function _temp2() {
          return _extends({}, pageProps, {
            urqlState: ssrCache ? ssrCache.extractData() : void 0,
            urqlClient: urqlClient
          });
        }
        function _temp4() {
          var props, appTreeProps;
          if ("undefined" != typeof window) {
            return _extends({}, pageProps, {
              urqlClient: urqlClient
            });
          }
          props = _extends({}, pageProps, {
            urqlClient: urqlClient
          });
          appTreeProps = isApp ? props : {
            pageProps: props
          };
          const _temp = function() {
            if (!options.neverSuspend) {
              return Promise.resolve(ssrPrepass(createElement(AppTree, appTreeProps))).then(_ref$1);
            }
          }();
          return _temp && _temp.then ? _temp.then(_temp2) : _temp2();
        }
        function _ref2(_AppOrPage$getInitial) {
          pageProps = _AppOrPage$getInitial;
        }
        var AppTree, isApp, ctx, ssrCache, clientConfig, urqlClient, pageProps;
        try {
          AppTree = appOrPageCtx.AppTree;
          ctx = (isApp = !!appOrPageCtx.Component) ? appOrPageCtx.ctx : appOrPageCtx;
          ssrCache = ssrExchange({
            initialState: void 0
          });
          if (!(clientConfig = getClientConfig(ssrCache, ctx)).exchanges) {
            clientConfig.exchanges = [ dedupExchange, cacheExchange, ssrCache, fetchExchange ];
          }
          if (urqlClient = initUrqlClient(clientConfig, !options.neverSuspend)) {
            ctx.urqlClient = urqlClient;
          }
          pageProps = {};
          const _temp3 = function _ref3() {
            if (AppOrPage.getInitialProps) {
              return Promise.resolve(AppOrPage.getInitialProps(appOrPageCtx)).then(_ref2);
            }
          }();
          return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4());
        } catch (e) {
          return Promise.reject(e);
        }
      };
    }
    return WithUrql;
  };
}

var urqlClient, ssr;

import React, { useState, createElement } from "react";

import ssrPrepass from "react-ssr-prepass";

import { createClient, ssrExchange, dedupExchange, cacheExchange, fetchExchange, Provider } from "urql";

urqlClient = null;

export { initUrqlClient, withUrqlClient };
//# sourceMappingURL=next-urql.es.js.map
