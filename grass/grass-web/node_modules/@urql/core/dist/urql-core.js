"use strict";

function _ref(a) {
  return a.kind === graphql.Kind.FIELD && "__typename" === a.name.value && !a.alias;
}

function withPromise(a) {
  a.toPromise = function() {
    return wonka.toPromise(wonka.take(1)(a));
  };
  return a;
}

function makeOperation(a, b, c) {
  c || (c = b.context);
  return {
    key: b.key,
    query: b.query,
    variables: b.variables,
    kind: a,
    context: c
  };
}

function _ref$1(a) {
  return a.path || a.extensions ? {
    message: a.message,
    path: a.path,
    extensions: a.extensions
  } : a.message;
}

function _ref$2(a) {
  var b = makeOperation(a.kind, a);
  b.query = formatDocument(a.query);
  return b;
}

function _ref7(a) {
  return "query" !== a.kind || "cache-only" !== a.context.requestPolicy;
}

function _ref8(a) {
  return addMetadata(a, {
    cacheOutcome: "miss"
  });
}

function _ref10(a) {
  return shouldSkip$1(a);
}

function _ref2(a) {
  return console.log("[Exchange debug]: Completed operation: ", a);
}

function _ref3(a) {
  return console.log("[Exchange debug]: Incoming operation: ", a);
}

function _ref$3(a) {
  return "query" === a.kind || "mutation" === a.kind;
}

function _ref2$1(a) {
  return "query" !== a.kind && "mutation" !== a.kind;
}

function _ref$4() {
  return !1;
}

function _ref2$2(a) {
  a.data = maskTypename(a.data);
  return a;
}

var graphql = require("graphql"), fetchSource = require("./408a05a6.js"), wonka = require("wonka"), collectTypes = function(a, b) {
  if (Array.isArray(a)) {
    for (var c = 0; c < a.length; c++) {
      collectTypes(a[c], b);
    }
  } else if ("object" == typeof a && null !== a) {
    for (c in a) {
      "__typename" === c && "string" == typeof a[c] ? b[a[c]] = 0 : collectTypes(a[c], b);
    }
  }
  return b;
}, collectTypesFromResponse = function(a) {
  return Object.keys(collectTypes(a, {}));
}, formatNode = function(a) {
  if (a.selectionSet && !a.selectionSet.selections.some(_ref)) {
    return fetchSource._extends({}, a, {
      selectionSet: fetchSource._extends({}, a.selectionSet, {
        selections: a.selectionSet.selections.concat([ {
          kind: graphql.Kind.FIELD,
          name: {
            kind: graphql.Kind.NAME,
            value: "__typename"
          }
        } ])
      })
    });
  }
}, formattedDocs = new Map, formatDocument = function(a) {
  a = fetchSource.keyDocument(a);
  var b = formattedDocs.get(a.__key);
  b || ((b = graphql.visit(a, {
    Field: formatNode,
    InlineFragment: formatNode
  })).__key = a.__key, formattedDocs.set(a.__key, b));
  return b;
}, maskTypename = function(a) {
  return a && "object" == typeof a ? Object.keys(a).reduce((function(b, c) {
    var d = a[c];
    "__typename" === c ? Object.defineProperty(b, "__typename", {
      enumerable: !1,
      value: d
    }) : Array.isArray(d) ? b[c] = d.map(maskTypename) : b[c] = d && "object" == typeof d && "__typename" in d ? maskTypename(d) : d;
    return b;
  }), {}) : a;
}, addMetadata = function(a, b) {
  return makeOperation(a.kind, a, fetchSource._extends({}, a.context, {
    meta: fetchSource._extends({}, a.context.meta, b)
  }));
}, noop = function() {}, applyDefinitions = function(a, b, c) {
  var d, f, g;
  for (d = 0; d < c.length; d++) {
    if (c[d].kind === graphql.Kind.FRAGMENT_DEFINITION) {
      f = c[d].name.value, g = fetchSource.stringifyDocument(c[d]);
      a.has(f) ? "production" !== process.env.NODE_ENV && a.get(f) !== g && console.warn("[WARNING: Duplicate Fragment] A fragment with name `" + f + "` already exists in this document.\nWhile fragment names may not be unique across your source, each name must be unique per document.") : (a.set(f, g), 
      b.push(c[d]));
    } else {
      b.push(c[d]);
    }
  }
}, shouldSkip = function(a) {
  return "subscription" !== (a = a.kind) && "query" !== a;
}, serializeResult = function(a) {
  var c, b = a.data;
  a = a.error;
  c = {};
  void 0 !== b && (c.data = JSON.stringify(b));
  a && (c.error = {
    graphQLErrors: a.graphQLErrors.map(_ref$1)
  }, a.networkError && (c.error.networkError = "" + a.networkError));
  return c;
}, deserializeResult = function(a, b) {
  var c = b.error;
  return {
    operation: a,
    data: (b = b.data) ? JSON.parse(b) : void 0,
    extensions: void 0,
    error: c ? new fetchSource.CombinedError({
      networkError: c.networkError ? Error(c.networkError) : void 0,
      graphQLErrors: c.graphQLErrors && c.graphQLErrors.length ? c.graphQLErrors : void 0
    }) : void 0
  };
}, ssrExchange = function(a) {
  function b() {
    for (var a; a = k.shift(); ) {
      delete e[a];
    }
  }
  function c(a) {
    return !l(a);
  }
  function d(a) {
    return deserializeResult(a, e[a.key]);
  }
  function f(a) {
    return l(a);
  }
  function g(a) {
    var c = a.operation;
    shouldSkip(c) || (a = serializeResult(a), e[c.key] = a);
  }
  var e = {}, k = [], m = function(a) {
    k.push(a.operation.key);
    1 === k.length && Promise.resolve().then(b);
  }, l = function(a) {
    return !shouldSkip(a) && void 0 !== e[a.key];
  }, h = function(b) {
    var e = b.client, h = b.forward;
    return function(b) {
      var q = a && "boolean" == typeof a.isClient ? !!a.isClient : !e.suspense, p = wonka.share(b);
      b = h(wonka.filter(c)(p));
      p = wonka.map(d)(wonka.filter(f)(p));
      q ? p = wonka.tap(m)(p) : b = wonka.tap(g)(b);
      return wonka.merge([ b, p ]);
    };
  };
  h.restoreData = function(a) {
    return fetchSource._extends(e, a);
  };
  h.extractData = function() {
    return fetchSource._extends({}, e);
  };
  a && a.initialState && h.restoreData(a.initialState);
  return h;
}, shouldSkip$1 = function(a) {
  return "mutation" !== (a = a.kind) && "query" !== a;
}, cacheExchange = function(a) {
  function b(a) {
    var c = m.get(a.key);
    "production" !== process.env.NODE_ENV && k(fetchSource._extends({}, {
      operation: a
    }, c ? {
      type: "cacheHit",
      message: "The result was successfully retried from the cache"
    } : {
      type: "cacheMiss",
      message: "The result could not be retrieved from the cache"
    }));
    c = fetchSource._extends({}, c, {
      operation: addMetadata(a, {
        cacheOutcome: c ? "hit" : "miss"
      })
    });
    "cache-and-network" === a.context.requestPolicy && (c.stale = !0, reexecuteOperation(e, a));
    return c;
  }
  function c(a) {
    return !shouldSkip$1(a) && n(a);
  }
  function d(a) {
    function c(a) {
      h.add(a);
    }
    var f, h, g, d = a.operation;
    if (d) {
      f = collectTypesFromResponse(a.data).concat(d.context.additionalTypenames || []);
      if ("mutation" === a.operation.kind) {
        h = new Set;
        "production" !== process.env.NODE_ENV && k({
          type: "cacheInvalidation",
          message: "The following typenames have been invalidated: " + f,
          operation: d,
          data: {
            typenames: f,
            response: a
          },
          source: "cacheExchange"
        });
        for (a = 0; a < f.length; a++) {
          (g = l[g = f[a]] || (l[g] = new Set)).forEach(c);
          g.clear();
        }
        h.forEach((function b(a) {
          m.has(a) && (d = m.get(a).operation, m.delete(a), reexecuteOperation(e, d));
        }));
      } else if ("query" === d.kind && a.data) {
        for (m.set(d.key, a), a = 0; a < f.length; a++) {
          (l[g = f[a]] || (l[g] = new Set)).add(d.key);
        }
      }
    }
  }
  function f(a) {
    return !shouldSkip$1(a) && !n(a);
  }
  var g = a.forward, e = a.client, k = a.dispatchDebug, m = new Map, l = Object.create(null), h = _ref$2, n = function(a) {
    var b = a.context.requestPolicy;
    return "query" === a.kind && "network-only" !== b && ("cache-only" === b || m.has(a.key));
  };
  return function(a) {
    var e = wonka.share(a);
    a = wonka.map(b)(wonka.filter(c)(e));
    e = wonka.tap(d)(g(wonka.filter(_ref7)(wonka.map(_ref8)(wonka.merge([ wonka.map(h)(wonka.filter(f)(e)), wonka.filter(_ref10)(e) ])))));
    return wonka.merge([ a, e ]);
  };
}, reexecuteOperation = function(a, b) {
  return a.reexecuteOperation(makeOperation(b.kind, b, fetchSource._extends({}, b.context, {
    requestPolicy: "network-only"
  })));
}, subscriptionExchange = function(a) {
  function b(a) {
    return "subscription" === (a = a.kind) || !!d && ("query" === a || "mutation" === a);
  }
  var c = a.forwardSubscription, d = a.enableAllOperations;
  return function(a) {
    function d(a) {
      return !l(a);
    }
    var e = a.client, f = a.forward, m = function(a) {
      var b = c({
        key: a.key.toString(36),
        query: graphql.print(a.query),
        variables: a.variables,
        context: fetchSource._extends({}, a.context)
      });
      return wonka.make((function(c) {
        function d(c) {
          return g(fetchSource.makeResult(a, c));
        }
        function m(c) {
          return g(fetchSource.makeErrorResult(a, c));
        }
        function f() {
          h || (h = !0, "subscription" === a.kind && e.reexecuteOperation(makeOperation("teardown", a, a.context)), 
          l());
        }
        var k, g = c.next, l = c.complete, h = !1;
        Promise.resolve().then((function() {
          h || (k = b.subscribe({
            next: d,
            error: m,
            complete: f
          }));
        }));
        return function() {
          h = !0;
          k && k.unsubscribe();
        };
      }));
    }, l = b;
    return function(a) {
      var b, c = wonka.share(a);
      a = wonka.mergeMap((function(a) {
        var b = a.key, d = wonka.filter((function(a) {
          return "teardown" === a.kind && a.key === b;
        }))(c);
        return wonka.takeUntil(d)(m(a));
      }))(wonka.filter(l)(c));
      b = f(wonka.filter(d)(c));
      return wonka.merge([ a, b ]);
    };
  };
}, debugExchange = function(a) {
  var d = a.forward;
  return "production" === process.env.NODE_ENV ? function b(a) {
    return d(a);
  } : function c(a) {
    return wonka.tap(_ref2)(d(wonka.tap(_ref3)(a)));
  };
}, dedupExchange = function(a) {
  var b = a.forward, c = a.dispatchDebug, d = new Set, f = function(a) {
    var b = a.key, e = a.kind;
    if ("teardown" === e) {
      return d.delete(b), !0;
    }
    if ("query" !== e && "subscription" !== e) {
      return !0;
    }
    e = d.has(b);
    d.add(b);
    e && "production" !== process.env.NODE_ENV && c({
      type: "dedup",
      message: "An operation has been deduped.",
      operation: a,
      source: "dedupExchange"
    });
    return !e;
  }, g = function(a) {
    d.delete(a.operation.key);
  };
  return function(a) {
    a = wonka.filter(f)(a);
    return wonka.tap(g)(b(a));
  };
}, fetchExchange = function(a) {
  var b = a.forward, c = a.dispatchDebug;
  return function(a) {
    var g, d = wonka.share(a);
    a = wonka.mergeMap((function(a) {
      var b = a.key, e = wonka.filter((function(a) {
        return "teardown" === a.kind && a.key === b;
      }))(d), f = fetchSource.makeFetchBody(a), g = fetchSource.makeFetchURL(a, f), n = fetchSource.makeFetchOptions(a, f);
      "production" !== process.env.NODE_ENV && c({
        type: "fetchRequest",
        message: "A fetch request is being executed.",
        operation: a,
        data: {
          url: g,
          fetchOptions: n
        },
        source: "fetchExchange"
      });
      return wonka.onPush((function(b) {
        var d = b.data ? void 0 : b.error;
        "production" !== process.env.NODE_ENV && c({
          type: d ? "fetchError" : "fetchSuccess",
          message: "A " + (d ? "failed" : "successful") + " fetch response has been returned.",
          operation: a,
          data: {
            url: g,
            fetchOptions: n,
            value: d || b
          },
          source: "fetchExchange"
        });
      }))(wonka.takeUntil(e)(fetchSource.makeFetchSource(a, g, n)));
    }))(wonka.filter(_ref$3)(d));
    g = b(wonka.filter(_ref2$1)(d));
    return wonka.merge([ a, g ]);
  };
}, fallbackExchange = function(a) {
  function b(a) {
    if ("teardown" !== a.kind && "production" !== process.env.NODE_ENV) {
      var b = 'No exchange has handled operations of kind "' + a.kind + "\". Check whether you've added an exchange responsible for these operations.";
      "production" !== process.env.NODE_ENV && c({
        type: "fallbackCatch",
        message: b,
        operation: a,
        source: "fallbackExchange"
      });
      console.warn(b);
    }
  }
  var c = a.dispatchDebug;
  return function(a) {
    return wonka.filter(_ref$4)(wonka.tap(b)(a));
  };
}, fallbackExchangeIO = fallbackExchange({
  dispatchDebug: noop
}), composeExchanges = function(a) {
  return function(b) {
    var c = b.client, d = b.dispatchDebug;
    return a.reduceRight((function(a, b) {
      return b({
        client: c,
        forward: a,
        dispatchDebug: function(a) {
          "production" !== process.env.NODE_ENV && d(fetchSource._extends({}, {
            timestamp: Date.now(),
            source: b.name
          }, a));
        }
      });
    }), b.forward);
  };
}, errorExchange = function(a) {
  function b(a) {
    var b = a.error;
    a = a.operation;
    b && c(b, a);
  }
  var c = a.onError;
  return function(a) {
    var c = a.forward;
    return function(a) {
      return wonka.tap(b)(c(a));
    };
  };
}, defaultExchanges = [ dedupExchange, cacheExchange, fetchExchange ], createClient = function(a) {
  return new Client(a);
}, Client = function(a) {
  var d, f, g, e, k, c = this;
  this.activeOperations = Object.create(null);
  this.queue = [];
  this.createOperationContext = function(a) {
    a || (a = {});
    return fetchSource._extends({}, {
      url: c.url,
      fetchOptions: c.fetchOptions,
      fetch: c.fetch,
      preferGetMethod: c.preferGetMethod
    }, a, {
      suspense: a.suspense || !1 !== a.suspense && c.suspense,
      requestPolicy: a.requestPolicy || c.requestPolicy
    });
  };
  this.createRequestOperation = function(a, b, d) {
    return makeOperation(a, b, c.createOperationContext(d));
  };
  this.executeQuery = function(a, b) {
    a = c.createRequestOperation("query", a, b);
    return c.executeRequestOperation(a);
  };
  this.executeSubscription = function(a, b) {
    a = c.createRequestOperation("subscription", a, b);
    return c.executeRequestOperation(a);
  };
  this.executeMutation = function(a, b) {
    a = c.createRequestOperation("mutation", a, b);
    return c.executeRequestOperation(a);
  };
  if ("production" !== process.env.NODE_ENV && !a.url) {
    throw Error("You are creating an urql-client without a url.");
  }
  d = noop;
  if ("production" !== process.env.NODE_ENV) {
    f = (d = wonka.makeSubject()).next, g = d.source;
    this.subscribeToDebugTarget = function b(a) {
      return wonka.subscribe(a)(g);
    };
    d = f;
  }
  this.url = a.url;
  this.fetchOptions = a.fetchOptions;
  this.fetch = a.fetch;
  this.suspense = !!a.suspense;
  this.requestPolicy = a.requestPolicy || "cache-first";
  this.preferGetMethod = !!a.preferGetMethod;
  this.maskTypename = !!a.maskTypename;
  f = wonka.makeSubject();
  e = f.next;
  this.operations$ = f.source;
  k = !1;
  this.dispatchOperation = function(a) {
    k = !0;
    for (a && e(a); a = c.queue.shift(); ) {
      e(a);
    }
    k = !1;
  };
  this.reexecuteOperation = function(a) {
    if ("mutation" === a.kind || 0 < (c.activeOperations[a.key] || 0)) {
      c.queue.push(a), k || Promise.resolve().then(c.dispatchOperation);
    }
  };
  a = composeExchanges(void 0 !== a.exchanges ? a.exchanges : defaultExchanges);
  this.results$ = wonka.share(a({
    client: this,
    dispatchDebug: d,
    forward: fallbackExchange({
      dispatchDebug: d
    })
  })(this.operations$));
  wonka.publish(this.results$);
};

Client.prototype.onOperationStart = function(a) {
  var b = a.key;
  this.activeOperations[b] = (this.activeOperations[b] || 0) + 1;
  this.dispatchOperation(a);
};

Client.prototype.onOperationEnd = function(a) {
  var b = a.key, c = this.activeOperations[b] || 0;
  if (0 >= (this.activeOperations[b] = 0 >= c ? 0 : c - 1)) {
    for (b = this.queue.length - 1; 0 <= b; b--) {
      this.queue[b].key === a.key && this.queue.splice(b, 1);
    }
    this.dispatchOperation(makeOperation("teardown", a, a.context));
  }
};

Client.prototype.executeRequestOperation = function(a) {
  var f, g, c = this, d = wonka.filter((function(b) {
    return b.operation.key === a.key;
  }))(this.results$);
  this.maskTypename && (d = wonka.map(_ref2$2)(d));
  if ("mutation" === a.kind) {
    return wonka.take(1)(wonka.onStart((function b() {
      return c.dispatchOperation(a);
    }))(d));
  }
  f = wonka.filter((function(b) {
    return "teardown" === b.kind && b.key === a.key;
  }))(this.operations$), g = wonka.filter((function(b) {
    return b.kind === a.kind && b.key === a.key && "cache-only" !== b.context.requestPolicy;
  }))(this.operations$);
  return wonka.onEnd((function() {
    c.onOperationEnd(a);
  }))(wonka.onStart((function() {
    c.onOperationStart(a);
  }))(wonka.switchMap((function(a) {
    return a.stale ? wonka.fromValue(a) : wonka.merge([ wonka.fromValue(a), wonka.map((function() {
      return fetchSource._extends({}, a, {
        stale: !0
      });
    }))(wonka.take(1)(g)) ]);
  }))(wonka.takeUntil(f)(d))));
};

Client.prototype.query = function(a, b, c) {
  c && "boolean" == typeof c.suspense || (c = fetchSource._extends({}, c, {
    suspense: !1
  }));
  return withPromise(this.executeQuery(fetchSource.createRequest(a, b), c));
};

Client.prototype.readQuery = function(a, b, c) {
  var d = null;
  wonka.subscribe((function(a) {
    d = a;
  }))(this.executeQuery(fetchSource.createRequest(a, b), c)).unsubscribe();
  return d;
};

Client.prototype.subscription = function(a, b, c) {
  return this.executeSubscription(fetchSource.createRequest(a, b), c);
};

Client.prototype.mutation = function(a, b, c) {
  return withPromise(this.executeMutation(fetchSource.createRequest(a, b), c));
};

exports.CombinedError = fetchSource.CombinedError;

exports.createRequest = fetchSource.createRequest;

exports.getOperationName = fetchSource.getOperationName;

exports.makeErrorResult = fetchSource.makeErrorResult;

exports.makeResult = fetchSource.makeResult;

exports.stringifyVariables = fetchSource.stringifyVariables;

exports.Client = Client;

exports.cacheExchange = cacheExchange;

exports.composeExchanges = composeExchanges;

exports.createClient = createClient;

exports.debugExchange = debugExchange;

exports.dedupExchange = dedupExchange;

exports.defaultExchanges = defaultExchanges;

exports.errorExchange = errorExchange;

exports.fallbackExchangeIO = fallbackExchangeIO;

exports.fetchExchange = fetchExchange;

exports.formatDocument = formatDocument;

exports.gql = function gql() {
  var a, b, c, d, f, g, e;
  for (a = arguments, b = new Map, c = [], d = [], f = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || "", 
  g = 1; g < arguments.length; g++) {
    (e = a[g]) && e.definitions ? d.push.apply(d, e.definitions) : f += e;
    f += a[0][g];
  }
  applyDefinitions(b, c, fetchSource.keyDocument(f).definitions);
  applyDefinitions(b, c, d);
  return fetchSource.keyDocument({
    kind: graphql.Kind.DOCUMENT,
    definitions: c
  });
};

exports.makeOperation = makeOperation;

exports.maskTypename = maskTypename;

exports.ssrExchange = ssrExchange;

exports.subscriptionExchange = subscriptionExchange;
//# sourceMappingURL=urql-core.js.map
