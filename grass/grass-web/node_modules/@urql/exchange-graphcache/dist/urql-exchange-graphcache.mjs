function n(a) {
  return a.name.value;
}

function t(a) {
  return a.selectionSet ? a.selectionSet.selections : [];
}

function aa(a, b) {
  var e, f, g, h, c = {}, d = 0;
  if (a.arguments && a.arguments.length) {
    for (e = 0, f = a.arguments.length; e < f; e++) {
      null != (h = valueFromASTUntyped((g = a.arguments[e]).value, b)) && (c[n(g)] = h, 
      d++);
    }
  }
  return 0 < d ? c : null;
}

function ba(a, b) {
  var d, e, f, g, h, c = {};
  if (!b) {
    return c;
  }
  if (a.variableDefinitions) {
    for (d = 0, e = a.variableDefinitions.length; d < e; d++) {
      c[g = n((f = a.variableDefinitions[d]).variable)] = void 0 === b[g] && f.defaultValue ? valueFromASTUntyped(f.defaultValue, b) : b[g];
    }
  }
  for (h in b) {
    h in c || (c[h] = b[h]);
  }
  return c;
}

function x(a, b) {
  var c = "";
  b.kind === Kind.INLINE_FRAGMENT ? c = a ? 'Inline Fragment on "' + a + '"' : "Inline Fragment" : b.kind === Kind.OPERATION_DEFINITION ? c = (b.name ? '"' + b.name.value + '"' : "Unnamed") + " " + b.operation : b.kind === Kind.FRAGMENT_DEFINITION && (c = '"' + b.name.value + '" Fragment');
  c && u.push(c);
}

function da() {
  return u.length ? "\n(Caused At: " + u.join(", ") + ")" : "";
}

function y(a, b, c) {
  if (!a) {
    throw a = b || "Minfied Error #" + c + "\n", "production" !== process.env.NODE_ENV && (a += da()), 
    (c = Error(a + "\nhttps://bit.ly/2XbVrpR#" + c)).name = "Graphcache Error", c;
  }
}

function A(a, b) {
  ca.has(a) || (console.warn(a + da() + "\nhttps://bit.ly/2XbVrpR#" + b), ca.add(a));
}

function C(a) {
  for (var b = 0; b < a.definitions.length; b++) {
    if (a.definitions[b].kind === Kind.OPERATION_DEFINITION) {
      return a.definitions[b];
    }
  }
  y(!1, "production" !== process.env.NODE_ENV ? "Invalid GraphQL document: All GraphQL documents must contain an OperationDefinitionnode for a query, subscription, or mutation." : "", 1);
}

function D(a) {
  var b, c, d;
  for (b = {}, c = 0; c < a.definitions.length; c++) {
    (d = a.definitions[c]).kind === Kind.FRAGMENT_DEFINITION && (b[n(d)] = d);
  }
  return b;
}

function ea(a, b) {
  var d, e, f, c = a.directives;
  if (!c) {
    return !0;
  }
  for (d = 0, e = c.length; d < e; d++) {
    if (("include" === (a = n(f = c[d])) || "skip" === a) && f.arguments && f.arguments[0] && "if" === n(f.arguments[0])) {
      return b = valueFromASTUntyped(f.arguments[0].value, b), "include" === a ? !!b : !b;
    }
  }
  return !0;
}

function fa(a) {
  for (var b = {}, c = 0; c < a.length; c++) {
    b[a[c].name] = a[c];
  }
  return b;
}

function na(a, b, c) {
  if (ia.test(c)) {
    return !0;
  }
  return !!(a = F(a, b, c)) && "NON_NULL" !== a.type.kind;
}

function oa(a, b, c) {
  if (!(a = F(a, b, c))) {
    return !1;
  }
  return "LIST" === (a = "NON_NULL" === a.type.kind ? a.type.ofType : a.type).kind && "NON_NULL" !== a.ofType.kind;
}

function F(a, b, c) {
  pa(a, b);
  a = a.types[b].fields[c];
  "production" !== process.env.NODE_ENV && (a || A("Invalid field: The field `" + c + "` does not exist on `" + b + "`, but the GraphQL document expects it to exist.\nTraversal will continue, however this may lead to undefined behavior!", 4));
  return a;
}

function pa(a, b) {
  y(a.types[b] && "OBJECT" === a.types[b].kind, "production" !== process.env.NODE_ENV ? "Invalid Object type: The type `" + b + "` is not an object in the defined schema, but the GraphQL document is traversing it." : "", 3);
}

function qa(a) {
  "production" !== process.env.NODE_ENV && A("Invalid resolver: `" + a + "` is not in the defined schema, but the `resolvers` option is referencing it.", 23);
}

function I(a, b) {
  return b ? a + "(" + stringifyVariables(b) + ")" : a;
}

function ra(a) {
  var b = a.indexOf("(");
  return -1 < b ? {
    fieldKey: a,
    fieldName: a.slice(0, b),
    arguments: JSON.parse(a.slice(b + 1, -1))
  } : {
    fieldKey: a,
    fieldName: a,
    arguments: null
  };
}

function sa(a, b) {
  return a.replace(/\./g, "%2e") + "." + b;
}

function ta(a) {
  var b = a.indexOf(".");
  return {
    entityKey: a.slice(0, b).replace(/%2e/g, "."),
    fieldKey: a = a.slice(b + 1)
  };
}

function J() {
  return Object.create(null);
}

function S(a, b, c, d) {
  K = a;
  L = b;
  M = J();
  Q = !!d;
  "production" !== process.env.NODE_ENV && (u.length = 0);
  c ? d || 0 < b.optimisticOrder.length ? (d || b.commutativeKeys.has(c) ? d && b.commutativeKeys.delete(c) : ua(b, c), 
  P = c, -1 === b.optimisticOrder.indexOf(c) && b.optimisticOrder.unshift(c), b.refLock[c] || (b.refLock[c] = J(), 
  b.links.optimistic[c] = new Map, b.records.optimistic[c] = new Map)) : (P = null, 
  va(b, c)) : P = null;
}

function T() {
  "production" !== process.env.NODE_ENV && ya();
  var b = L, c = P;
  Q = !1;
  P = null;
  if (c && -1 < b.optimisticOrder.indexOf(c)) {
    for (c = b.optimisticOrder.length; 0 <= --c && b.refLock[b.optimisticOrder[c]] && b.commutativeKeys.has(b.optimisticOrder[c]); ) {
      Aa(b.optimisticOrder[c]);
    }
  }
  M = L = K = null;
  "production" !== process.env.NODE_ENV && (u.length = 0);
  "test" === process.env.NODE_ENV || b.defer || (b.defer = !0, Promise.resolve().then((function a() {
    S("read", b, null);
    L.gc.forEach(wa);
    !function xa() {
      function a(a) {
        var f, c = ta(a), e = c.entityKey;
        void 0 !== (f = W(e, c = c.fieldKey)) ? b[a] = ":" + stringifyVariables(f) : void 0 !== (f = V(e, c)) ? b[a] = stringifyVariables(f) : b[a] = void 0;
      }
      if (L.storage) {
        Q = !0;
        K = "read";
        var b = J();
        L.persist.forEach(a);
        Q = !1;
        L.storage.writeData(b);
        L.persist.clear();
      }
    }();
    T();
    b.defer = !1;
  })));
}

function ya() {
  y(null !== M, "production" !== process.env.NODE_ENV ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2);
  return M;
}

function Ba(a, b, c, d) {
  var e = (a = P ? a.optimistic[P] : a.base).get(b);
  void 0 === e && a.set(b, e = J());
  void 0 !== d || P ? e[c] = d : delete e[c];
}

function Ca(a, b, c) {
  var d, e, f, g, h, k;
  for (e = !Q && "read" === K && P && L.commutativeKeys.has(P), f = 0, g = L.optimisticOrder.length; f < g; f++) {
    h = L.optimisticOrder[f];
    e = e && h !== P;
    if (!(!(k = a.optimistic[h]) || e && L.commutativeKeys.has(h) || Q && "write" !== K && !L.commutativeKeys.has(h)) && void 0 !== (d = k.get(b)) && c in d) {
      return d[c];
    }
  }
  return void 0 !== (d = a.base.get(b)) ? d[c] : void 0;
}

function Da(a, b, c, d) {
  var e = void 0 !== b[c] ? b[c] : 0;
  b = b[c] = e + d | 0;
  void 0 !== a && (0 >= b ? a.add(c) : 0 >= e && 0 < b && a.delete(c));
}

function Ea(a, b, c, d) {
  var e, f, g;
  if ("string" == typeof c) {
    Da(a, b, c, d);
  } else if (Array.isArray(c)) {
    for (e = 0, f = c.length; e < f; e++) {
      (g = c[e]) && Da(a, b, g, d);
    }
  }
}

function Fa(a, b, c) {
  if (void 0 !== c) {
    for (var d in c) {
      b.has(d) || (a.push(ra(d)), b.add(d));
    }
  }
}

function Ga(a, b, c, d) {
  var e, f, g;
  Fa(a, b, d.base.get(c));
  for (e = 0, f = L.optimisticOrder.length; e < f; e++) {
    void 0 !== (g = d.optimistic[L.optimisticOrder[e]]) && Fa(a, b, g.get(c));
  }
}

function wa(a, b, c) {
  var d, e;
  if (0 < (L.refCount[a] || 0)) {
    c.delete(a);
  } else {
    for (d in L.refLock) {
      if (0 < ((b = L.refLock[d])[a] || 0)) {
        return;
      }
      delete b[a];
    }
    delete L.refCount[a];
    c.delete(a);
    L.records.base.delete(a);
    if (d = L.links.base.get(a)) {
      L.links.base.delete(a);
      for (e in d) {
        Ea(c, L.refCount, d[e], -1);
      }
    }
  }
}

function U(a, b) {
  "__typename" !== b && (a !== L.queryRootKey ? M[a] = !0 : void 0 !== b && (M[a + "." + b] = !0));
}

function V(a, b) {
  U(a, b);
  return Ca(L.records, a, b);
}

function W(a, b) {
  U(a, b);
  return Ca(L.links, a, b);
}

function X(a, b, c) {
  U(a, b);
  !Q && L.storage && L.persist.add(sa(a, b));
  Ba(L.records, a, b, c);
}

function Ha(a, b, c) {
  var e, f, g, d = L;
  if (P) {
    e = d.refLock[P] || (d.refLock[P] = J());
    f = d.links.optimistic[P];
  } else {
    e = d.refCount;
    f = d.links.base;
    g = d.gc;
  }
  f = (f = f && f.get(a)) && f[b];
  U(a, b);
  !Q && L.storage && L.persist.add(sa(a, b));
  Ba(d.links, a, b, c);
  Ea(g, e, f, -1);
  Ea(g, e, c, 1);
}

function ua(a, b) {
  var c = a.optimisticOrder.indexOf(b);
  -1 === c ? a.optimisticOrder.unshift(b) : a.commutativeKeys.has(b) || (Ia(a, b), 
  a.optimisticOrder.splice(c, 1), a.optimisticOrder.unshift(b));
  a.commutativeKeys.add(b);
}

function Ia(a, b) {
  a.refLock[b] && (delete a.refLock[b], delete a.records.optimistic[b], delete a.links.optimistic[b]);
}

function va(a, b) {
  var c = a.optimisticOrder.indexOf(b);
  -1 < c && (a.optimisticOrder.splice(c, 1), a.commutativeKeys.delete(b));
  Ia(a, b);
}

function Ja(a, b) {
  for (var c in a) {
    Ha(b, c, a[c]);
  }
}

function Ka(a, b) {
  for (var c in a) {
    X(b, c, a[c]);
  }
}

function Aa(a) {
  var c, b = M;
  M = J();
  (c = L.links.optimistic[a]) && c.forEach(Ja);
  (c = L.records.optimistic[a]) && c.forEach(Ka);
  M = b;
  va(L, a);
}

function La(a) {
  var b = L.links, c = L.records, d = [], e = new Set;
  U(a);
  Ga(d, e, a, b);
  Ga(d, e, a, c);
  return d;
}

function Na(a) {
  return 0 < a.__internal.path.length && a.__internal.errorMap ? a.__internal.errorMap[a.__internal.path.join(".")] : void 0;
}

function Oa(a, b, c, d, e, f, g) {
  a = {
    store: a,
    variables: b,
    fragments: c,
    parent: {
      __typename: d
    },
    parentTypeName: d,
    parentKey: e,
    parentFieldKey: "",
    fieldName: "",
    error: void 0,
    partial: !1,
    optimistic: !!f,
    __internal: {
      path: [],
      errorMap: void 0
    }
  };
  if (g && g.graphQLErrors) {
    for (b = 0; b < g.graphQLErrors.length; b++) {
      (c = g.graphQLErrors[b]).path && c.path.length && (a.__internal.errorMap || (a.__internal.errorMap = Object.create(null)), 
      a.__internal.errorMap[c.path.join(".")] = c);
    }
  }
  return a;
}

function Pa(a, b, c, d, e, f) {
  Ma.current = a;
  a.parent = b;
  a.parentTypeName = c;
  a.parentKey = d;
  a.parentFieldKey = e;
  a.fieldName = f;
  a.error = Na(a);
}

function Qa(a, b, c, d) {
  if (!b) {
    return !1;
  }
  var e = a.typeCondition ? n(a.typeCondition) : null;
  if (!e || b === e) {
    return !0;
  }
  "production" !== process.env.NODE_ENV && A("Heuristic Fragment Matching: A fragment is trying to match against the `" + b + "` type, but the type condition is `" + e + "`. Since GraphQL allows for interfaces `" + e + "` may be aninterface.\nA schema needs to be defined for this match to be deterministic, otherwise the fragment will be matched heuristically!", 16);
  return !t(a).some((function(a) {
    if (a.kind !== Kind.FIELD) {
      return !1;
    }
    a = I(n(a), aa(a, d));
    return !(void 0 !== V(c, a) || void 0 !== W(c, a));
  }));
}

function Ra(a, b, c, d) {
  var e, f = 0;
  return function() {
    var g, h, k, l;
    if (void 0 !== e) {
      if (void 0 !== (g = e())) {
        return g;
      }
      e = void 0;
      "production" !== process.env.NODE_ENV && u.pop();
    }
    for (;f < c.length; ) {
      if (ea(g = c[f++], d.variables)) {
        if (g.kind === Kind.FIELD) {
          return g;
        }
        if (void 0 !== (g = g.kind === Kind.INLINE_FRAGMENT ? g : d.fragments[n(g)])) {
          if (d.store.schema) {
            h = d.store.schema;
            if (k = a) {
              (l = g.typeCondition ? n(g.typeCondition) : null) && k !== l ? h.types[l] && "OBJECT" === h.types[l].kind ? h = l === k : (y(h.types[l] && ("INTERFACE" === h.types[l].kind || "UNION" === h.types[l].kind), "production" !== process.env.NODE_ENV ? "Invalid Abstract type: The type `" + l + "` is not an Interface or Union type in the defined schema, but a fragment in the GraphQL document is using it as a type condition." : "", 5), 
              pa(h, k), h = h.isSubType(l, k)) : h = !0;
            } else {
              h = !1;
            }
          } else {
            h = Qa(g, a, b, d.variables);
          }
          if (h) {
            return "production" !== process.env.NODE_ENV && x(a, g), (e = Ra(a, b, t(g), d))();
          }
        }
      }
    }
  };
}

function Sa(a) {
  return void 0 === a ? null : a;
}

function Ta(a, b, c, d, e) {
  S("write", a.data, e || null);
  a = Ua(a, b, c, d);
  T();
  return a;
}

function Ua(a, b, c, d, e) {
  var f = C(b.query), g = {
    data: c,
    dependencies: ya()
  }, h = a.rootFields[f.operation];
  a = Oa(a, ba(f, b.variables), D(b.query), h, h, !!e, d);
  "production" !== process.env.NODE_ENV && x(h, f);
  Va(a, h, t(f), c);
  "production" !== process.env.NODE_ENV && u.pop();
  return g;
}

function Va(a, b, c, d) {
  var h, k, l, p, m, w, v, B, e = b === a.store.rootFields.query, f = !e && !!a.store.rootNames[b], g = f || e ? b : d.__typename;
  if (g) {
    f || e || !b || X(b, "__typename", g);
    c = Ra(g, b || g, c, a);
    for (;h = c(); ) {
      e = I(k = n(h), l = aa(h, a.variables));
      m = d[p = h.alias ? h.alias.value : n(h)];
      if ("production" !== process.env.NODE_ENV) {
        if (f || void 0 !== m) {
          if (a.store.schema && g && "__typename" !== k) {
            w = a.store.schema, v = g;
            ia.test(B = k) || F(w, v, B);
          }
        } else {
          k = a.optimistic ? "\nYour optimistic result may be missing a field!" : "";
          l = void 0 === h.selectionSet ? "scalar (number, boolean, etc)" : "selection set";
          "production" !== process.env.NODE_ENV && A("Invalid undefined: The field at `" + e + "` is `undefined`, but the GraphQL query expects a " + l + " for this field." + k, 13);
          continue;
        }
      }
      if ("__typename" !== k) {
        a.__internal.path.push(p);
        if (a.optimistic && f) {
          if (!(m = a.store.optimisticMutations[k])) {
            continue;
          }
          Pa(a, d, g, g, e, k);
          m = d[p] = Sa(m(l || {}, a.store, a));
        }
        h.selectionSet ? b && !f ? (p = b + "." + e, Ha(b || g, e, h = Wa(a, t(h), Sa(m), p))) : Wa(a, t(h), Sa(m)) : b && !f && X(b || g, e, null === m && Na(a) ? void 0 : m);
        f && (h = a.store.updates[g][k]) && (Pa(a, d, g, g, g + "." + e, k), d[k] = m, h(d, l || {}, a.store, a));
        a.__internal.path.pop();
      }
    }
  } else {
    "production" !== process.env.NODE_ENV && A("Couldn't find __typename when writing.\nIf you're writing to the cache manually have to pass a `__typename` property on each entity in your data.", 14);
  }
}

function Wa(a, b, c, d) {
  var e, f, g, h;
  if (Array.isArray(c)) {
    for (e = Array(c.length), f = 0, g = c.length; f < g; f++) {
      a.__internal.path.push(f);
      h = Wa(a, b, c[f], d ? d + "." + f : void 0);
      e[f] = h;
      a.__internal.path.pop();
    }
    return e;
  }
  if (null === c) {
    return Na(a) ? void 0 : null;
  }
  e = a.store.keyOfEntity(c);
  f = c.__typename;
  "production" !== process.env.NODE_ENV && (!d || a.store.keys[c.__typename] || null !== e || "string" != typeof f || Xa.test(f) || A("Invalid key: The GraphQL query at the field at `" + d + "` has a selection set, but no key could be generated for the data at this field.\nYou have to request `id` or `_id` fields for all selection sets or create a custom `keys` config for `" + f + "`.\nEntities without keys will be embedded directly on the parent entity. If this is intentional, create a `keys` config for `" + f + "` that always returns null.", 15));
  Va(a, d = e || d, b, c);
  return d || null;
}

function Y(a) {
  var b, c, d, e, f, g, h, k, l, p, m, w, v;
  this.keyOfField = I;
  this.resolveFieldByKey = this.resolve;
  a || (a = {});
  this.resolvers = a.resolvers || {};
  this.optimisticMutations = a.optimistic || {};
  this.keys = a.keys || {};
  d = "Query", e = "Mutation", f = "Subscription";
  if (a.schema) {
    g = function ha(a) {
      function b(a) {
        switch (a.kind) {
         case "OBJECT":
         case "INTERFACE":
          return {
            name: a.name,
            kind: a.kind,
            interfaces: e(a.interfaces || []),
            fields: e(a.fields.map(c))
          };

         case "UNION":
          return {
            name: a.name,
            kind: a.kind,
            types: e(a.possibleTypes || [])
          };
        }
      }
      function c(a) {
        return {
          name: a.name,
          type: a.type,
          args: e(a.args)
        };
      }
      var d, e, f, g, h, k;
      d = {}, e = fa, f = {
        query: (a = a.__schema).queryType ? a.queryType.name : null,
        mutation: a.mutationType ? a.mutationType.name : null,
        subscription: a.subscriptionType ? a.subscriptionType.name : null,
        types: void 0,
        isSubType: function(a, b) {
          var c = d[a], e = d[b];
          return c && e ? "UNION" === c.kind ? !!c.types[b] : "OBJECT" !== c.kind && "OBJECT" === e.kind ? !!e.interfaces[a] : a === b : !1;
        }
      };
      if (a.types) {
        f.types = d;
        for (g = 0; g < a.types.length; g++) {
          if ((h = a.types[g]) && h.name) {
            (k = b(h)) && (d[h.name] = k);
          }
        }
      }
      return f;
    }(a.schema);
    d = g.query || d;
    e = g.mutation || e;
    f = g.subscription || f;
    g.types && (this.schema = g);
  }
  this.updates = ((b = {})[e] = a.updates && a.updates.Mutation || {}, b[f] = a.updates && a.updates.Subscription || {}, 
  b);
  this.rootFields = {
    query: d,
    mutation: e,
    subscription: f
  };
  this.rootNames = ((c = {})[d] = "query", c[e] = "mutation", c[f] = "subscription", 
  c);
  a = d;
  this.data = {
    defer: !1,
    gc: new Set,
    persist: new Set,
    queryRootKey: a,
    refCount: J(),
    refLock: J(),
    links: {
      optimistic: J(),
      base: new Map
    },
    records: {
      optimistic: J(),
      base: new Map
    },
    commutativeKeys: new Set,
    optimisticOrder: [],
    storage: null
  };
  if (this.schema && "production" !== process.env.NODE_ENV) {
    a = this.schema;
    b = this.keys;
    if ("production" !== process.env.NODE_ENV) {
      for (h in b) {
        "production" !== process.env.NODE_ENV && (a.types[h] || A("Invalid Object type: The type `" + h + "` is not an object in the defined schema, but the `keys` option is referencing it.", 20));
      }
    }
    h = this.schema;
    a = this.updates;
    if ("production" !== process.env.NODE_ENV) {
      if (h.mutation) {
        b = h.types[h.mutation].fields;
        c = a[h.mutation] || {};
        for (k in c) {
          "production" !== process.env.NODE_ENV && void 0 === b[k] && A("Invalid mutation field: `" + k + "` is not in the defined schema, but the `updates.Mutation` option is referencing it.", 21);
        }
      }
      if (h.subscription) {
        k = h.types[h.subscription].fields;
        h = a[h.subscription] || {};
        for (l in h) {
          "production" !== process.env.NODE_ENV && void 0 === k[l] && A("Invalid subscription field: `" + l + "` is not in the defined schema, but the `updates.Subscription` option is referencing it.", 22);
        }
      }
    }
    l = this.schema;
    k = this.resolvers;
    if ("production" !== process.env.NODE_ENV) {
      for (p in k) {
        if ("Query" === p) {
          if (l.query) {
            h = l.types[l.query].fields;
            for (m in k.Query) {
              h[m] || qa("Query." + m);
            }
          } else {
            qa("Query");
          }
        } else if (l.types[p]) {
          if ("INTERFACE" === l.types[p].kind || "UNION" === l.types[p].kind) {
            "production" !== process.env.NODE_ENV && A("Invalid resolver: `" + p + "` does not match to a concrete type in the schema, but the `resolvers` option is referencing it. Implement the resolver for the types that " + ("UNION" === l.types[p].kind ? "make up the union" : "implement the interface") + " instead.", 26);
          } else {
            h = l.types[p].fields;
            for (w in k[p]) {
              h[w] || qa(p + "." + w);
            }
          }
        } else {
          qa(p);
        }
      }
    }
    m = this.schema;
    p = this.optimisticMutations;
    if ("production" !== process.env.NODE_ENV && m.mutation) {
      m = m.types[m.mutation].fields;
      for (v in p) {
        "production" !== process.env.NODE_ENV && (m[v] || A("Invalid optimistic mutation field: `" + v + "` is not a mutation field in the defined schema, but the `optimistic` option is referencing it.", 24));
      }
    }
  }
}

function Za(a, b, c, d, e) {
  S("read", a.data, c && e || null);
  a = Ya(a, b, c, d);
  T();
  return a;
}

function Ya(a, b, c, d) {
  var e = C(b.query), f = a.rootFields[e.operation], g = t(e);
  a = Oa(a, ba(e, b.variables), D(b.query), f, f, !1, d);
  "production" !== process.env.NODE_ENV && x(f, e);
  c = f !== a.store.rootFields.query ? $a(a, f, g, c || {}) : Z(a, f, g, {});
  "production" !== process.env.NODE_ENV && u.pop();
  return {
    dependencies: ya(),
    partial: a.partial || !c,
    data: c || null
  };
}

function $a(a, b, c, d) {
  var f, g, e = a.store.rootNames[b] ? b : d.__typename;
  if ("string" != typeof e) {
    return d;
  }
  b = Ra(b, b, c, a);
  for (e = {
    __typename: e
  }; c = b(); ) {
    g = d[f = c.alias ? c.alias.value : n(c)];
    a.__internal.path.push(f);
    c.selectionSet && null !== g ? (g = Sa(g), e[f] = ab(a, t(c), g)) : e[f] = g;
    a.__internal.path.pop();
  }
  return e;
}

function ab(a, b, c) {
  if (Array.isArray(c)) {
    for (var d = Array(c.length), e = 0, f = c.length; e < f; e++) {
      a.__internal.path.push(e), d[e] = ab(a, b, c[e]), a.__internal.path.pop();
    }
    return d;
  }
  if (null === c) {
    return null;
  }
  return null !== (d = a.store.keyOfEntity(c)) ? void 0 === (a = Z(a, d, b, {})) ? null : a : $a(a, c.__typename, b, c);
}

function Z(a, b, c, d, e) {
  var k, l, p, m, w, v, B, N, r, G, E, q, z, H, f = a.store, g = b === f.rootFields.query, h = e && f.keyOfEntity(e) || b;
  "production" !== process.env.NODE_ENV && !g && a.store.rootNames[h] && A("Invalid root traversal: A selection was being read on `" + h + "` which is an uncached root type.\nThe `" + a.store.rootFields.mutation + "` and `" + a.store.rootFields.subscription + "` types are special Operation Root Types and cannot be read back from the cache.", 25);
  if ("string" == typeof (b = g ? b : V(h, "__typename") || e && e.__typename)) {
    if (e && b !== e.__typename) {
      "production" !== process.env.NODE_ENV && A("Invalid resolver data: The resolver at `" + h + "` returned an invalid typename that could not be reconciled with the cache.", 8);
    } else {
      c = Ra(b, h, c, a);
      for (l = !1, p = !1; void 0 !== (k = c()); ) {
        m = n(k), w = aa(k, a.variables), v = k.alias ? k.alias.value : n(k), N = h + "." + (B = I(m, w)), 
        r = V(h, B), G = e ? e[m] : void 0, E = f.resolvers[b];
        if ("production" !== process.env.NODE_ENV && f.schema && b) {
          q = f.schema, z = b;
          ia.test(H = m) || F(q, z, H);
        }
        if ("__typename" === m) {
          d[v] = b;
        } else {
          q = void 0;
          a.__internal.path.push(v);
          if (void 0 !== G && void 0 === k.selectionSet) {
            q = G;
          } else if (y(null !== K, "production" !== process.env.NODE_ENV ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2), 
          "read" === K && E && "function" == typeof E[m]) {
            if (Pa(a, d, b, h, N, m), void 0 !== r && (d[v] = r), q = E[m](d, w || {}, f, a), 
            k.selectionSet && (q = bb(a, b, m, N, t(k), d[v], q)), f.schema && null === q && !na(f.schema, b, m)) {
              return;
            }
          } else {
            k.selectionSet ? void 0 !== G ? q = bb(a, b, m, N, t(k), d[v], G) : void 0 !== (w = W(h, B)) ? q = cb(a, w, b, m, t(k), d[v]) : "object" == typeof r && null !== r && (q = r) : q = r;
          }
          void 0 === q && Na(a) && (p = !0, q = null);
          a.__internal.path.pop();
          if (void 0 === q && f.schema && na(f.schema, b, m)) {
            p = !0, d[v] = null;
          } else {
            if (void 0 === q) {
              return;
            }
            l = !0;
            d[v] = q;
          }
        }
      }
      p && (a.partial = !0);
      return g && p && !l ? void 0 : d;
    }
  }
}

function bb(a, b, c, d, e, f, g) {
  var h, k, l, p, m;
  if (Array.isArray(g)) {
    h = !(h = a.store).schema || oa(h.schema, b, c);
    for (k = Array(g.length), l = 0, p = g.length; l < p; l++) {
      a.__internal.path.push(l);
      m = bb(a, b, c, d + "." + l, e, null != f ? f[l] : void 0, g[l]);
      a.__internal.path.pop();
      if (void 0 !== m || h) {
        k[l] = void 0 !== m ? m : null;
      } else {
        return;
      }
    }
    return k;
  }
  if (null == g) {
    return g;
  }
  if (null === f) {
    return null;
  }
  if ("string" == typeof g || "object" == typeof g && "string" == typeof g.__typename) {
    return b = f || {}, "string" == typeof g ? Z(a, g, e, b) : Z(a, d, e, b, g);
  }
  "production" !== process.env.NODE_ENV && A("Invalid resolver value: The field at `" + d + "` is a scalar (number, boolean, etc), but the GraphQL query expects a selection set for this field.", 9);
}

function cb(a, b, c, d, e, f) {
  var g, h, k, l, p;
  if (Array.isArray(b)) {
    g = (g = a.store).schema && oa(g.schema, c, d);
    for (h = Array(b.length), k = 0, l = b.length; k < l; k++) {
      a.__internal.path.push(k);
      p = cb(a, b[k], c, d, e, null != f ? f[k] : void 0);
      a.__internal.path.pop();
      if (void 0 !== p || g) {
        h[k] = void 0 !== p ? p : null;
      } else {
        return;
      }
    }
    return h;
  }
  return null === b || null === f ? null : Z(a, b, e, f || {});
}

function db(a, b) {
  return makeOperation(a.kind, a, _extends({}, a.context, {
    meta: _extends({}, a.context.meta, {
      cacheOutcome: b
    })
  }));
}

function eb(a, b) {
  return makeOperation(a.kind, a, _extends({}, a.context, {
    requestPolicy: b
  }));
}

function fb(a) {
  return fromArray(a[0]);
}

function gb(a, b) {
  return a.push(b), a;
}

function hb(a) {
  return "query" === a.kind && "network-only" !== a.context.requestPolicy;
}

function ib(a) {
  return "query" !== a.kind || "network-only" === a.context.requestPolicy;
}

function jb(a) {
  return "miss" !== a.outcome || "cache-only" === a.operation.context.requestPolicy;
}

function kb(a) {
  return function(b) {
    function c(a, b) {
      var k, c = a.operation, d = a.error, f = a.extensions, g = c.key;
      if ("mutation" === c.kind) {
        h(b, R.get(g));
        R.delete(g);
      } else {
        ua(z.data, c.key);
      }
      if (a.data) {
        if (h(b, Ta(z, c, a.data, a.error, g).dependencies), g = Za(z, c, a.data, a.error, g), 
        a.data = g.data, "query" === c.kind) {
          h(b, k = g.dependencies);
        }
      } else {
        S("read", z.data, c.key, void 0), T();
      }
      k && e(a.operation, k);
      return {
        data: a.data,
        error: d,
        extensions: f,
        operation: c
      };
    }
    function d(a) {
      var b = Za(z, a), c = b.data ? b.partial ? "partial" : "hit" : "miss";
      e(a, b.dependencies);
      return {
        outcome: c,
        operation: a,
        data: b.data,
        dependencies: b.dependencies
      };
    }
    function e(a, b) {
      for (var c in b) {
        (ja[c] || (ja[c] = [])).push(a.key), ka.set(a.key, a);
      }
    }
    function f(a) {
      var b, c, d, e, f, k, l, O, m, H;
      if ("query" === a.kind) {
        ua(z.data, a.key);
      } else if ("teardown" === a.kind) {
        ka.delete(a.key), S("read", z.data, a.key, void 0), T();
      } else if ("mutation" === a.kind && "network-only" !== a.context.requestPolicy) {
        b = z, c = a.key;
        "production" !== process.env.NODE_ENV && y("mutation" === C(a.query).operation, "production" !== process.env.NODE_ENV ? "writeOptimistic(...) was called with an operation that is not a mutation.\nThis case is unsupported and should never occur." : "", 10);
        S("write", b.data, c, !0);
        b = Ua(b, a, {}, void 0, !0);
        T();
        b = b.dependencies;
        a: {
          for (d in b) {
            d = !1;
            break a;
          }
          d = !0;
        }
        if (!d) {
          for (e in b) {
            la[e] = !0;
          }
          R.set(a.key, b);
          h(e = new Set, b);
          g(a, e);
        }
      }
      e = makeOperation;
      d = a.kind;
      b = a.key;
      c = formatDocument(a.query);
      if (a.variables) {
        f = C(a.query);
        if ((k = a.variables) && f.variableDefinitions) {
          for (l = {}, O = 0, m = f.variableDefinitions.length; O < m; O++) {
            l[H = n(f.variableDefinitions[O].variable)] = k[H];
          }
          f = l;
        } else {
          f = void 0;
        }
      } else {
        f = a.variables;
      }
      return e(d, {
        key: b,
        query: c,
        variables: f
      }, a.context);
    }
    function g(a, b) {
      b.forEach((function(b) {
        var c, d;
        if (b !== a.key) {
          if (c = ka.get(b)) {
            ka.delete(b);
            d = "cache-first";
            za.has(b) && (za.delete(b), d = "cache-and-network");
            E.reexecuteOperation(eb(c, d));
          }
        }
      }));
    }
    function h(a, b) {
      var c, d, e;
      if (b) {
        for (c in b) {
          if (b = ja[c]) {
            ja[c] = [];
            for (d = 0, e = b.length; d < e; d++) {
              a.add(b[d]);
            }
          }
        }
      }
    }
    function k(a) {
      for (var b in a) {
        if (la[b]) {
          return !0;
        }
      }
      return !1;
    }
    function p(a) {
      "production" !== process.env.NODE_ENV && q({
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache",
        operation: a.operation,
        source: "cacheExchange"
      });
      return db(a.operation, "miss");
    }
    function m(a) {
      return "miss" === a.outcome && "cache-only" !== a.operation.context.requestPolicy && !k(a.dependencies);
    }
    function w(a) {
      var b = a.operation, c = a.outcome, d = a.dependencies, e = {
        operation: db(b, c),
        data: a.data,
        error: a.error,
        extensions: a.extensions
      };
      if ("cache-and-network" === b.context.requestPolicy || "cache-first" === b.context.requestPolicy && "partial" === c) {
        e.stale = !0, k(d) ? "cache-and-network" === b.context.requestPolicy && za.add(b.key) : E.reexecuteOperation(eb(b, "network-only"));
      }
      "production" !== process.env.NODE_ENV && q({
        type: "cacheHit",
        message: "A requested operation was found and returned from the cache.",
        operation: a.operation,
        data: {
          value: e
        },
        source: "cacheExchange"
      });
      return e;
    }
    function v(a) {
      var b = new Set, d = c(a, b);
      g(a.operation, b);
      return d;
    }
    function B(a) {
      return !R.has(a.operation.key);
    }
    function N(a) {
      var b, d, e;
      if (ma.push(a) < R.size) {
        return empty;
      }
      for (b = 0; b < ma.length; b++) {
        ua(z.data, ma[b].operation.key);
      }
      for (d in la) {
        delete la[d];
      }
      b = [];
      d = new Set;
      for (;e = ma.shift(); ) {
        b.push(c(e, d));
      }
      g(a.operation, d);
      return fromArray(b);
    }
    function r(a) {
      return R.has(a.operation.key);
    }
    var H, R, ma, ka, la, za, ja, G = b.forward, E = b.client, q = b.dispatchDebug, z = new Y(a);
    a && a.storage && (H = a.storage.readData().then((function l(b) {
      var e, f, g, h, c = z.data, d = a.storage;
      S("write", c, null);
      for (e in b) {
        if (void 0 !== (f = b[e])) {
          h = (g = ta(e)).entityKey;
          g = g.fieldKey;
          ":" === f[0] ? Ha(h, g, JSON.parse(f.slice(1))) : X(h, g, JSON.parse(f));
        }
      }
      T();
      c.storage = d;
    })));
    R = new Map, ma = [], ka = new Map, la = J(), za = new Set, ja = J();
    return function(a) {
      var b, c;
      a = share(a);
      b = H ? mergeMap(fb)(take(1)(combine(scan(gb, [])(a), fromPromise(H)))) : empty;
      b = share(concat([ b, a ]));
      a = share(map(d)(filter(hb)(b)));
      b = filter(ib)(b);
      c = map(p)(filter(m)(a));
      a = map(w)(filter(jb)(a));
      c = share(G(map(f)(merge([ b, c ]))));
      b = map(v)(filter(B)(c));
      c = mergeMap(N)(filter(r)(c));
      return merge([ b, c, a ]);
    };
  };
}

function lb(a) {
  return a && a.networkError && !a.response && ("undefined" != typeof navigator && !1 === navigator.onLine || /request failed|failed to fetch|network\s?error/i.test(a.networkError.message));
}

function offlineExchange(a) {
  return function(b) {
    function e(a) {
      var b, c, d, e, f;
      if (b = "mutation" === a.operation.kind && lb(a.error)) {
        a: {
          b = N;
          d = (c = a.operation).variables || J(), e = D(c.query);
          c = [].concat(t(C(c.query)));
          for (;f = c.pop(); ) {
            if (ea(f, d)) {
              if (f.kind !== Kind.FIELD) {
                (f = f.kind === Kind.INLINE_FRAGMENT ? f : e[n(f)]) && c.push.apply(c, t(f));
              } else if (b[n(f)]) {
                b = !0;
                break a;
              }
            }
          }
          b = !1;
        }
      }
      return b ? (r.push(a.operation), G(), !1) : !0;
    }
    function h(a) {
      return "query" === a.operation.kind && lb(a.error) ? (B(eb(a.operation, "cache-only")), 
      r.push(a.operation), !1) : !0;
    }
    var p, m, w, v, B, N, r, G, E, q, z, l = a.storage;
    if (l && l.onOnline && l.readMetadata && l.writeMetadata) {
      p = b.forward, m = b.client;
      b = b.dispatchDebug;
      w = makeSubject(), v = w.source, B = w.next, N = a.optimistic || {}, r = [], G = function c() {
        var a, b, c;
        for (a = [], b = 0; b < r.length; b++) {
          "mutation" === (c = r[b]).kind && a.push({
            query: print(c.query),
            variables: c.variables
          });
        }
        l.writeMetadata(a);
      }, E = !1;
      l.onOnline(q = function d() {
        var a, b;
        if (!E) {
          E = !0;
          for (a = 0; a < r.length; a++) {
            "mutation" === (b = r[a]).kind && B(makeOperation("teardown", b));
          }
          for (a = 0; a < r.length; a++) {
            m.reexecuteOperation(r[a]);
          }
          r.length = 0;
          E = !1;
          G();
        }
      });
      l.readMetadata().then((function g(a) {
        if (a) {
          for (var b = 0; b < a.length; b++) {
            r.push(m.createRequestOperation("mutation", createRequest(a[b].query, a[b].variables)));
          }
          q();
        }
      }));
      z = kb(a)({
        client: m,
        dispatchDebug: b,
        forward: function f(a) {
          return filter(e)(p(a));
        }
      });
      return function k(a) {
        a = share(a);
        a = merge([ v, a ]);
        return filter(h)(z(a));
      };
    }
    return kb(a)(b);
  };
}

var ca, u, ia, K, L, M, P, Q, Ma, Xa;

import { Kind } from "graphql/language/kinds.mjs";

import { valueFromASTUntyped } from "graphql/utilities/valueFromASTUntyped.mjs";

import { print } from "graphql/language/printer.mjs";

import { _ as _extends } from "./5301ccd2.mjs";

import { share, mergeMap, take, combine, scan, fromPromise, empty, concat, map, filter, merge, fromArray, makeSubject } from "wonka";

import { stringifyVariables, createRequest, formatDocument, makeOperation } from "@urql/core";

ca = new Set, u = [];

ia = /^__/;

K = null, L = null, M = null, P = null, Q = !1;

Ma = {
  current: null
};

Xa = /^__|PageInfo|(Connection|Edge)$/;

Y.prototype.keyOfEntity = function(a) {
  if (Ma.current && a === Ma.current.parent) {
    return Ma.current.parentKey;
  }
  if (null == a || "string" == typeof a) {
    return a || null;
  }
  if (!a.__typename) {
    return null;
  }
  if (this.rootNames[a.__typename]) {
    return a.__typename;
  }
  var b;
  this.keys[a.__typename] ? b = this.keys[a.__typename](a) : null != a.id ? b = "" + a.id : null != a._id && (b = "" + a._id);
  return b ? a.__typename + ":" + b : null;
};

Y.prototype.resolve = function(a, b, c) {
  b = I(b, c);
  if (!(a = this.keyOfEntity(a))) {
    return null;
  }
  return void 0 !== (c = V(a, b)) ? c : W(a, b) || null;
};

Y.prototype.invalidate = function(a, b, c) {
  var e, d = this.keyOfEntity(a);
  y(d, "production" !== process.env.NODE_ENV ? "object" == "Can't generate a key for invalidate(...).\nYou have to pass an id or _id field or create a custom `keys` field for `" + typeof a ? a.__typename : a + "`." : "", 19);
  a = b ? [ {
    fieldKey: I(b, c)
  } ] : La(d);
  b = 0;
  for (c = a.length; b < c; b++) {
    void 0 !== W(d, e = a[b].fieldKey) ? Ha(d, e, void 0) : X(d, e, void 0);
  }
};

Y.prototype.inspectFields = function(a) {
  return (a = this.keyOfEntity(a)) ? La(a) : [];
};

Y.prototype.updateQuery = function(a, b) {
  (a = createRequest(a.query, a.variables)).query = formatDocument(a.query);
  null !== (b = b(this.readQuery(a))) && Ua(this, a, b);
};

Y.prototype.readQuery = function(a) {
  (a = createRequest(a.query, a.variables)).query = formatDocument(a.query);
  return Ya(this, a).data;
};

Y.prototype.readFragment = function(a, b, c) {
  var d, e;
  if (d = (a = D(a = formatDocument(a)))[(d = Object.keys(a))[0]]) {
    e = d.typeCondition.name.value;
    "string" == typeof b || b.__typename || (b.__typename = e);
    (b = this.keyOfEntity(b)) ? ("production" !== process.env.NODE_ENV && x(e, d), c = Z(c = Oa(this, c || {}, a, e, b), b, t(d), {}) || null, 
    "production" !== process.env.NODE_ENV && u.pop()) : ("production" !== process.env.NODE_ENV && A("Can't generate a key for readFragment(...).\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + e + "`.", 7), 
    c = null);
  } else {
    "production" !== process.env.NODE_ENV && A("readFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 6), 
    c = null;
  }
  return c;
};

Y.prototype.writeFragment = function(a, b, c) {
  var d, e, f;
  if (d = (a = D(a = formatDocument(a)))[(d = Object.keys(a))[0]]) {
    b = _extends({}, {
      __typename: e = d.typeCondition.name.value
    }, b);
    (f = this.keyOfEntity(b)) ? ("production" !== process.env.NODE_ENV && x(e, d), Va(c = Oa(this, c || {}, a, e, f, void 0), f, t(d), b), 
    "production" !== process.env.NODE_ENV && u.pop()) : "production" !== process.env.NODE_ENV && A("Can't generate a key for writeFragment(...) data.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + e + "`.", 12);
  } else {
    "production" !== process.env.NODE_ENV && A("writeFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 11);
  }
};

export { Y as Store, kb as cacheExchange, offlineExchange, Za as query, Ta as write };
//# sourceMappingURL=urql-exchange-graphcache.mjs.map
