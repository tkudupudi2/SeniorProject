"use strict";

var _rollupPluginBabelHelpers = require("./7832a774.js"), core = require("@urql/core"), defaultPageInfo = {
  __typename: "PageInfo",
  endCursor: null,
  startCursor: null,
  hasNextPage: !1,
  hasPreviousPage: !1
}, ensureKey = function(a) {
  return "string" == typeof a ? a : null;
}, concatEdges = function(a, f, e) {
  var b, c, d, l, p;
  for (b = new Set, c = 0, d = f.length; c < d; c++) {
    "string" == typeof (l = a.resolve(f[c], "node")) && b.add(l);
  }
  f = f.slice();
  c = 0;
  for (d = e.length; c < d; c++) {
    "string" != typeof (p = a.resolve(l = e[c], "node")) || b.has(p) || (b.add(p), f.push(l));
  }
  return f;
}, concatNodes = function(a, f) {
  var e, b, c, d;
  for (e = new Set, b = 0, c = a.length; b < c; b++) {
    "string" == typeof (d = a[b]) && e.add(d);
  }
  a = a.slice();
  b = 0;
  for (c = f.length; b < c; b++) {
    "string" != typeof (d = f[b]) || e.has(d) || (e.add(d), a.push(d));
  }
  return a;
}, compareArgs = function(a, f) {
  var e, b, c, d;
  for (e in f) {
    if ("first" !== e && "last" !== e && "after" !== e && "before" !== e) {
      if (!(e in a)) {
        return !1;
      }
      if (typeof (b = a[e]) != typeof (c = f[e]) || "object" != typeof b ? b !== c : core.stringifyVariables(b) !== core.stringifyVariables(c)) {
        return !1;
      }
    }
  }
  for (d in a) {
    if ("first" !== d && "last" !== d && "after" !== d && "before" !== d && !(d in f)) {
      return !1;
    }
  }
  return !0;
}, getPage = function(a, f, e) {
  var c, d, l, p, b = ensureKey(a.resolve(f, e));
  if (!b) {
    return null;
  }
  e = a.resolve(b, "__typename");
  f = a.resolve(b, "edges") || [];
  c = a.resolve(b, "nodes") || [];
  if ("string" != typeof e) {
    return null;
  }
  e = {
    __typename: e,
    edges: f,
    nodes: c,
    pageInfo: defaultPageInfo
  };
  if ("string" == typeof (d = a.resolve(b, "pageInfo"))) {
    b = ensureKey(a.resolve(d, "__typename"));
    c = ensureKey(a.resolve(d, "endCursor"));
    l = ensureKey(a.resolve(d, "startCursor")), p = a.resolve(d, "hasNextPage");
    d = a.resolve(d, "hasPreviousPage");
    null === (b = e.pageInfo = {
      __typename: "string" == typeof b ? b : "PageInfo",
      hasNextPage: "boolean" == typeof p ? p : !!c,
      hasPreviousPage: "boolean" == typeof d ? d : !!l,
      endCursor: c,
      startCursor: l
    }).endCursor && (c = f[f.length - 1]) && (c = a.resolve(c, "cursor"), b.endCursor = ensureKey(c));
    null === b.startCursor && (f = f[0]) && (a = a.resolve(f, "cursor"), b.startCursor = ensureKey(a));
  }
  return e;
};

exports.relayPagination = function(a) {
  void 0 === a && (a = {});
  var f = a.mergeMode || "inwards";
  return function(a, b, c, d) {
    var e, p, t, x, m, r, q, n, k, u, h, g, v, w;
    e = d.fieldName;
    if (0 !== (t = (p = c.inspectFields(a = d.parentKey).filter((function(a) {
      return a.fieldName === e;
    }))).length)) {
      for (x = null, m = [], r = [], q = [], n = [], k = _rollupPluginBabelHelpers._extends({}, defaultPageInfo), 
      u = 0; u < t; u++) {
        g = (h = p[u]).fieldKey;
        if (null !== (h = h.arguments) && compareArgs(b, h) && null !== (g = getPage(c, a, g))) {
          if ("inwards" === f && "number" == typeof h.last && "number" == typeof h.first) {
            k = g.edges.slice(0, h.first + 1);
            v = g.edges.slice(-h.last), w = g.nodes.slice(0, h.first + 1);
            h = g.nodes.slice(-h.last);
            m = concatEdges(c, m, k);
            r = concatEdges(c, v, r);
            q = concatNodes(q, w);
            n = concatNodes(h, n);
            k = g.pageInfo;
          } else {
            h.after ? (m = concatEdges(c, m, g.edges), q = concatNodes(q, g.nodes), k.endCursor = g.pageInfo.endCursor, 
            k.hasNextPage = g.pageInfo.hasNextPage) : h.before ? (r = concatEdges(c, g.edges, r), 
            n = concatNodes(g.nodes, n), k.startCursor = g.pageInfo.startCursor, k.hasPreviousPage = g.pageInfo.hasPreviousPage) : ("number" == typeof h.last ? (r = concatEdges(c, g.edges, r), 
            n = concatNodes(g.nodes, n)) : (m = concatEdges(c, m, g.edges), q = concatNodes(q, g.nodes)), 
            k = g.pageInfo);
          }
          g.pageInfo.__typename !== k.__typename && (k.__typename = g.pageInfo.__typename);
          x !== g.__typename && (x = g.__typename);
        }
      }
      if ("string" == typeof x) {
        if (!ensureKey(c.resolve(a, e, b))) {
          if (d.store.schema) {
            d.partial = !0;
          } else {
            return;
          }
        }
        return {
          __typename: x,
          edges: "inwards" === f ? concatEdges(c, m, r) : concatEdges(c, r, m),
          nodes: "inwards" === f ? concatNodes(q, n) : concatNodes(n, q),
          pageInfo: {
            __typename: k.__typename,
            endCursor: k.endCursor,
            startCursor: k.startCursor,
            hasNextPage: k.hasNextPage,
            hasPreviousPage: k.hasPreviousPage
          }
        };
      }
    }
  };
};

exports.simplePagination = function(a) {
  var f, e, b, c;
  void 0 === a && (a = {});
  void 0 === (f = a.offsetArgument) && (f = "skip");
  void 0 === (e = a.limitArgument) && (e = "limit");
  void 0 === (b = a.mergeMode) && (b = "after");
  c = function(a, c) {
    var b, d, l, m;
    for (b in c) {
      if (b !== f && b !== e) {
        if (!(b in a)) {
          return !1;
        }
        if (typeof (d = a[b]) != typeof (l = c[b]) || "object" != typeof d ? d !== l : core.stringifyVariables(d) !== core.stringifyVariables(l)) {
          return !1;
        }
      }
    }
    for (m in a) {
      if (m !== f && m !== e && !(m in c)) {
        return !1;
      }
    }
    return !0;
  };
  return function(a, e, p, t) {
    var d, m, l, q, n, k, u, h, g, v, w, y;
    d = t.fieldName;
    if (0 !== (l = (m = p.inspectFields(a = t.parentKey).filter((function(a) {
      return a.fieldName === d;
    }))).length)) {
      for (q = new Set, n = [], k = null, u = 0; u < l; u++) {
        g = (h = m[u]).fieldKey;
        if (null !== (h = h.arguments) && c(e, h) && (g = p.resolve(a, g), h = h[f], null !== g && 0 !== g.length && "number" == typeof h)) {
          for (v = [], w = 0; w < g.length; w++) {
            q.has(y = g[w]) || (v.push(y), q.add(y));
          }
          n = (!k || h > k) == ("after" === b) ? n.concat(v) : v.concat(n);
          k = h;
        }
      }
      if (p.resolve(a, d, e)) {
        return n;
      }
      if (t.store.schema) {
        return t.partial = !0, n;
      }
    }
  };
};
//# sourceMappingURL=urql-exchange-graphcache-extras.js.map
